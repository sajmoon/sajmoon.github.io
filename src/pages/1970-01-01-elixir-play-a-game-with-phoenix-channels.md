---
title: "Elixir: Play a game with Phoenix channels."
slug: elixir-play-a-game-with-phoenix-channels
date: 1970-01-01T00:00:00.000Z
tags: Elixir, Phoenix, WebSockets
draft: true
---

Let us play a game with channels in [Phoenix](http://www.phoenixframework.org/)! A simple multiplayer game where the users is handed cards and are to take a some tricks. Using channels we can make a real time app like this in a breeze (I hope).

### Rules
We are going to make a game called [Oh hell](https://en.wikipedia.org/wiki/Oh_Hell). Each player is handed a hand.
The player then have to guess how many tricks he will take. The player has to follow color, and the user with the "highest" card wins. There is Trump, a suite that is higher then the other. The user how guesses that he will take the most tricks decides which color will be the trump that round.

### User interactions.
User joins the game lobby.
When 4 joined the game starts.
Each player is handed 10 cards.
All players guess how many tricks they will win that round.
One player decides trump, he also starts the round by selecting one card from his hand.
The other players take turn to place a card.
The one how wins this round gets a trick and starts the next round.
When all players have played all cards, we see how many tricks each player has and if it matche the number the said the would get. Score is given accordingly.

This game is called Plump in Swedish, and [Oh hell](https://en.wikipedia.org/wiki/Oh_Hell) in english.

## Development

We are going to start with the user interaction, since thats the channel part.

Create a new phoenix project `mix phoenix.new plump`.
Build and compile everything you like then create a channel.


```language-bash
~/C/plump ❯❯❯ mix phoenix.gen.channel Game games
* creating web/channels/game_channel.ex
* creating test/channels/game_channel_test.exs

Add the channel to your `web/channels/user_socket.ex` handler, for example:

    channel "games:lobby", Plump.GameChannel
```

After you add your channel handler as described about we got a basic channel setup.

Open test test file. We get a setup block and three tests from the generator.

Let's add our own test.

### Let all users know a new user has joined.
Every time a user joins push a message letting everybody know there is a new friend in the lobby. Create a test to ensure we broadcast it to everyone.

```language-elixir
  test "user joins channel a welcome message is sent", %{socket: socket} do
    assert_broadcast "user:join", %{id: 1}
  end
```

Run the tests and it breaks.
```language-elixir
1) test user joins channel a welcome message is sent (Plump.GameChannelTest)
     test/channels/game_channel_test.exs:12
     No message matching %Phoenix.Socket.Broadcast{event: "user:join", payload: %{id: 1}} after 100ms.
     The process mailbox is empty.
     stacktrace:
       test/channels/game_channel_test.exs:13
```

Our channel defines a join method that was generated by phoenix. So if we want to broadcast a message on join here might be the place to do that. This is how the code generated looks.
 
```language-elixir
  def join("games:lobby", payload, socket) do
    if authorized?(payload) do
      {:ok, socket}
    else
      {:error, %{reason: "unauthorized"}}
    end
  end
```
First lets remove all the authorization that is going on. If you check the method `authorized?` it always returns true. It's something that tells us where to put our implementation later when we need authentication. 

To broadcast on join we test a naïve solution. Call `broadcast socket "user:join", %{id: 1}` doesn't work. Elixir provides us with a nice error message.

```language-elixir
def join("games:lobby", payload, socket) do
  broadcast socket, "shout", payload
  {:ok, socket}
end
```
Running the tests gives us this:

```language-elixir
5) test shout broadcasts to games:lobby (Plump.GameChannelTest)
     test/channels/game_channel_test.exs:27
     ** (EXIT from #PID<0.249.0>) an exception was raised:
         ** (RuntimeError) `push` and `broadcast` can only be called after the socket has finished joining.
     To push a message on join, send to self and handle in handle_info/2, ie:

         def join(topic, auth_msg, socket) do
           ...
           send(self, :after_join)
           {:ok, socket}
         end

         def handle_info(:after_join, socket) do
           push socket, "feed", %{list: feed_items(socket)}
           {:noreply, socket}
         end

             (phoenix) lib/phoenix/channel.ex:346: Phoenix.Channel.assert_joined!/1
             (phoenix) lib/phoenix/channel.ex:288: Phoenix.Channel.broadcast/3
             (plump) web/channels/game_channel.ex:5: Plump.GameChannel.join/3
             (phoenix) lib/phoenix/channel/server.ex:154: Phoenix.Channel.Server.init/1
             (stdlib) gen_server.erl:328: :gen_server.init_it/6
             (stdlib) proc_lib.erl:240: :proc_lib.init_p_do_apply/3
```

It tells us exactly why it didn't work. We need to finish the join method and handle the broadcast later. Lets implement the exact solution provided to us.

```language-elixir
  def join("games:lobby", payload, socket) do
    send(self, :after_join)
    {:ok, socket}
  end

  def handle_info(:after_join, socket) do
    broadcast socket, "user:join", %{id: 1}
    {:noreply, socket}
  end
```

Tests are green!

What happens when a second user joins? Refactor the tests, create a helper method to join users to the channel and test for the expected behavior.

```language-elixir

defp join_channel channel_name, id do
  {:ok, _, socket} =
    socket("user_id", %{})
    |> subscribe_and_join(GameChannel, channel_name)

  {:ok, socket}
end

setup do
  {:ok, socket} = join_channel "games:lobby", 1

  {:ok, socket: socket}
end

test "user joins channel a welcome message is sent", %{socket: socket} do
  assert_broadcast "user:join", %{id: 1}
end

test "two users in a channel", %{socket: socket} do
  assert_broadcast "user:join", %{id: 1}
  user_2 = join_channel "games:lobby", 2
  assert_broadcast "user:join", %{id: 2}
end
```

Run the tests and they fail, since we hard coded what id should be sent with the broadcast.

We modify how we connect to the server. We pass along a struct with the id of the user.

```language-elixir
defp join_channel channel_name, id do
  {:ok, _, socket} =
    socket("user_id", %{})
    |> subscribe_and_join(GameChannel, channel_name, %{id: id})

  {:ok, socket}
end
```

And in our implementation we claim the payload of the message and send it to all connected users with the `broadcast` method.

```language-elixir
def join("games:lobby", payload, socket) do
  send(self, {:after_join, payload})
  {:ok, socket}
end

def handle_info({:after_join, payload}, socket) do
  broadcast socket, "user:join", payload
  {:noreply, socket}
end
```

And we are all green!

### Keep a list of all active users.

We could use a database for this, but it seems a bit overkill. `Ecto` gives us a presistant layer to store things in. But we don't need persistance now. Let us instead keep some state in an `Agent`. It will not be persisted but we could learn something about Agent. That sounds fun, everybody goes "Wee"!

We start by writing some tests. We want the state to be initialized with a count of 0, and increased when we add users. The test file is located in `test/lib/game_store_test.exs`.

```language-elixir
defmodule Plump.GameStoreTest do
  use ExUnit.Case, async: false

  setup do
    {:ok, bucket} = Plump.GameStore.start_link
    {:ok, bucket: bucket}
  end

  test "Initialized with count 0" do
    assert Plump.GameStore.count == 0
  end

  test "add a player increases count of players" do
    Plump.GameStore.add(%{id: 1})
    assert Plump.GameStore.count == 1
  end
end
```

To implement this behavior we create the file `GameStore`as `lib/plump/game_store_test.exs`.

```language-elixir
defmodule Plump.GameStore do
  def start_link do
    Agent.start_link(fn -> %{count: 0} end, name: __MODULE__)
    {:ok, self}
  end

  def count do
    Agent.get(__MODULE__, fn %{count: count} ->
      count
    end)
  end

  def add user do
    Agent.update(__MODULE__, fn %{count: count} ->
      %{count: count + 1}
    end)
  end
end
```

This is a simple agent that only stores a count, we will need to modify this later to keep track of the users too.

We have made some decisions about the agent that we might want to reconsider. The agent is named, thus we can only have one. This is fine, but you should be aware that the agent is unique because of it.

Also, the test setup block returns the bucket pid, aka the pid to the agent. That is not necessary since we have named it and could be removed. However, the pattern matching for `{:ok, bucket}`also serves to ensure that starting the Agent returned `:ok`. So it's like an assertion.

### Display the stats when new users join.
So, all the work we put in to create the Agent should be used. When a new users joins we want to know how many users have joined so far.

We modify the tests.

```language-elixir
test "user joins channel a message is sent, and nr of players in channel" do
  assert_broadcast "user:join", %{id: 1}
  assert_broadcast "user:stats", %{count: 1}
end

test "two users in a channel" do
  assert_broadcast "user:join", %{id: 1}
  assert_broadcast "user:stats", %{count: 1}
  join_channel "games:lobby", 2
  assert_broadcast "user:join", %{id: 2}
  assert_broadcast "user:stats", %{count: 2}
end
```

That is the behavior we want. Now over to the implementation.

```language-elixir
def join("games:lobby", payload, socket) do
  Plump.GameStore.add payload
  send(self, {:after_join, payload})
  {:ok, socket}
end

def handle_info({:after_join, payload}, socket) do
  broadcast socket, "user:join", payload
  count = Plump.GameStore.count
  broadcast socket, "user:stats", %{count: count}
  {:noreply, socket}
end
```

This is pretty straight forward; when a user joins we add it to the agent, and broadcast the updated statistics to all users.

Already here we see a problem in our design. GameStore.count returns a primitive value, but that is clear that we should have named that function statistics and it should have returned a struct `%{count: count}`. That would have made it easy to extend with information about running games, when the time comes.

This will still not make our tests green. For that we need to start the agent before the tests.
```language-elixir
setup do
  {:ok, bucket} = Plump.GameStore.start_link()
  {:ok, socket} = join_channel "games:lobby", 1

  {:ok, socket: socket}
end
```
This step is needed because we have not added the Agent to our application tree yet. This works for now.

### Refactoring.
As we can see above, we have some methods that could use a new name and a new return type.

We start with how we want to use it:
```language-elixir
def handle_info({:after_join, payload}, socket) do
  broadcast socket, "user:join", payload
  statistics = Plump.GameStore.statistics
  broadcast socket, "user:stats", statistics
  {:noreply, socket}
end
```

Fix the GameStore accordingly.
```language-elixir
def statistics do
  Agent.get(__MODULE__, fn %{count: count} ->
    %{count: count}
  end)
end
```

And the tests.

```language-elixir
test "Initialized with count 0" do
  %{count: count} = Plump.GameStore.statistics
  assert count == 0
end

test "add a player increases count of players" do
  Plump.GameStore.add(%{id: 1})
  %{count: count} = Plump.GameStore.statistics
  assert count == 1
end
```

Also refactor how the `:after_join` is handles.

```language-elixir
def handle_info({:after_join, payload}, socket) do
  statistics = Plump.GameStore.statistics

  %{socket: socket, statistics: statistics}
  |> broadcast_user_join(payload)
  |> broadcast_statistics()

  {:noreply, socket}
end

defp broadcast_user_join %{socket: socket, statistics: statistics} = params, payload do
  broadcast socket, "user:join", payload
  params
end

defp broadcast_statistics %{socket: socket, statistics: statistics} = params do
  broadcast socket, "user:stats", statistics
  params
end
```

Perfect. Each of the private functions return the `socket` so we can continue the pipe.

### Start the game.
When we have 4 players we should start the game.
Every game should have an own channel.
The players should get cards.
Let's start with that.

```language-elixir

test "If 4 players, the game should start", %{socket: socket} do
  join_channel "games:lobby", 2
  join_channel "games:lobby", 3
  join_channel "games:lobby", 4

  assert_broadcast "user:stats", %{count: 4}

  assert_broadcast "game:start", %{users: [1, 2, 3, 4]}
end
```

We join the game, and add 3 more players. This is a bit ugly and should be change. Now we don't want the first user to be added automatically.

Remove the join_channel statement from the setup block, and add the user 1 to the game where needed.

Run the tests and they fail. I decided to send a list of all users who are to be in the current game as payload.

Implementation time!

```language-elixir
def handle_info({:after_join, payload}, socket) do
  statistics = Plump.GameStore.statistics

  %{socket: socket, statistics: statistics}
  |> broadcast_user_join(payload)
  |> broadcast_statistics()
  |> start_game()

  {:noreply, socket}
end

defp start_game %{socket: socket, statistics: %{count: 4}} = params do
  broadcast socket, "game:start", %{users: [1,2,3,4]}
  {:ok, params}
end
defp start_game params do
  {:error, params}
end
```

We have hard coded the user ids. To fix this we need to fix our store.

We should store all users, and all games created. Not just a count of each.

We update the tests and the store.

```language-elixir
test "list players" do
  Plump.GameStore.add(%{id: 1})

  assert 1 == Plump.GameStore.players
  |> HashDict.to_list()
  |> Enum.count()
end

test "create a new game" do
  %{game_count: count} = Plump.GameStore.statistics
  assert count == 0

  Plump.GameStore.new_game(%{game_id: 1})
  %{game_count: count} = Plump.GameStore.statistics
  assert count == 1

  assert 1 == Plump.GameStore.games
  |> HashDict.to_list()
  |> Enum.count()
end
```

These tests assume we have a `games` and `players` method returning a HashDict of players.

Let's change the store to match. We also update the games counter to a new name, `games_count`.

We initialize the state we need.
```language-elixir
def start_link do
  Agent.start_link(fn -> %{count: 0, game_count: 0, users: HashDict.new, games: HashDict.new} end, name: __MODULE__)
  {:ok, self}
end
```

And create the methods to return the players and games.
```language-elixir
def players do
  Agent.get(__MODULE__, fn %{users: users} = state ->
    users
  end)
end

def games do
  Agent.get(__MODULE__, fn %{games: games} = state ->
    games
  end)
end
```

To add them to the respective list we need to modify the add user and new_games methods.

```language-elixir
def new_game game do
  Agent.update(__MODULE__, fn %{game_count: game_count, games: games} = state ->
    games = HashDict.put(games, game.game_id, game)
    %{state | game_count: game_count + 1, games: games}
  end)
end
```

Alright, we create the failing test to test the user id list and a game id. We are using 1 for now.

```language-elixir
test "broadcast of new games contains user ids" do
  join_channel "games:lobby", 10
  join_channel "games:lobby", 20
  join_channel "games:lobby", 30
  join_channel "games:lobby", 40

  assert_broadcast "user:stats", %{count: 4}

  assert_broadcast "game:start", %{users: [10, 20, 30, 40], game_id: 1}
end
```

We return a list of keys.

```language-elixir
defp start_game %{socket: socket, statistics: %{count: 4}} = params do
  players = Plump.GameStore.players()

  player_keys = players
  |> HashDict.keys()
  |> Enum.sort()

  game_id = 1
  Plump.GameStore.new_game %{game_id: game_id, players: players}

  broadcast socket, "game:start", %{users: player_keys, game_id: game_id}
  {:ok, params}
end
```

We have some major problems with our implementation so far. For example if more people then 4 join, what happens?

### Game room
That way the user can see if s/he was selected to join the game. That is it for the lobby part of the game. Next we need to move the selected players to a game room for that specific game and hand them cards.

```language-bash
$ mix phoenix.gen.channel Room rooms                                                                                                                             master
* creating web/channels/room_channel.ex
* creating test/channels/room_channel_test.exs

Add the channel to your `web/channels/user_socket.ex` handler, for example:

    channel "rooms:lobby", Plump.RoomChannel
```

We create a room channel to handle the gameplay. Make sure to add it with a wildcard.

```language-elixir
channel "rooms:*", Plump.RoomChannel
```

Also clear out the test and channel code generated for us by Phoenix generators.





