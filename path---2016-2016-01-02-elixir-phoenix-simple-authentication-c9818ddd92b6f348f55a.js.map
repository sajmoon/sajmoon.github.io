{"version":3,"sources":["webpack:///path---2016-2016-01-02-elixir-phoenix-simple-authentication-c9818ddd92b6f348f55a.js","webpack:///./.cache/json/2016-2016-01-02-elixir-phoenix-simple-authentication.json"],"names":["webpackJsonp","528","module","exports","data","site","siteMetadata","title","author","markdownRemark","id","html","frontmatter","date","pathContext","slug"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,MAAQC,cAAgBC,MAAA,uBAAAC,OAAA,gBAAuDC,gBAAmBC,GAAA,sIAAAC,KAAA,uobAAggbC,aAAsfL,MAAA,0CAAAM,KAAA,sBAA8EC,aAAgBC,KAAA","file":"path---2016-2016-01-02-elixir-phoenix-simple-authentication-c9818ddd92b6f348f55a.js","sourcesContent":["webpackJsonp([275924165586894],{\n\n/***/ 528:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Tinkering with Code.\",\"author\":\"Simon Ström\"}},\"markdownRemark\":{\"id\":\"/Users/simon/Code/sajmoon.github.io/src/pages/2016-01-02-elixir-phoenix-simple-authentication.md absPath of file >>> MarkdownRemark\",\"html\":\"<p>A simple Phoenix authentication flow for an JSON api. Using <a href=\\\"https://jwt.io/\\\">JSON Web Tokens</a> via <a href=\\\"https://github.com/bryanjos/joken\\\">Joken</a> and <a href=\\\"https://github.com/sajmoon/mellon\\\">Mellon</a> for access controller.</p>\\n<h2>The basics.</h2>\\n<p>Let’s start from scratch. Create a new Phoenix Application. Read the <a href=\\\"http://www.phoenixframework.org/docs/up-and-running\\\">Phoenix guide</a> to get started.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-sh\\\"><code>$ mix phoenix.new --no-brunch app_name\\n$ cd app_name\\n$ mix ecto.setup</code></pre>\\n      </div>\\n<h2>Create a user model</h2>\\n<p>We will use a generator now and remove most of the code, but obviously you don’t have to.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-sh\\\"><code>$ mix phoenix.gen.json User users email:string password_hash:string</code></pre>\\n      </div>\\n<p>We will want the emails to be unique so modify the migration file to include the following that will generate a index of all emails for us.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>create unique_index(:users, [:email])</code></pre>\\n      </div>\\n<p>We need to modify the routes, so let’s do that. We start by adding all possible CRUD routes in <code>web/routes.ex</code>.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>pipeline :api do\\n  plug :accepts, [\\\"json\\\"]\\nend\\n\\nscope \\\"/api/\\\" do\\n  pipe_through :api\\n  resources \\\"/users\\\", UserController\\nend</code></pre>\\n      </div>\\n<p>Then fix the database.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>$ mix ecto.migrate</code></pre>\\n      </div>\\n<p>We will not use the UserController but my memory is always messing with me and I need both the tests and controller to remember stuff.</p>\\n<h2>Registrate new users</h2>\\n<p>New users will <code>POST</code> to <code>/auth/</code> all data needed and a user will be created.</p>\\n<p>The route will be:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>scope \\\"/api/\\\" do\\n  pipe_through :api\\n  resources \\\"/users\\\", UserController\\n  \\n  post \\\"/auth\\\", RegistrationController, :create\\nend</code></pre>\\n      </div>\\n<p>So we need a new controller called <code>RegistrationController</code> located  in <code>web/controllers/registration_controller.ex</code>. The tests for that controller will be in <code>tests/controller/registration_controller_test.exs</code>. Create them both. See the full code further down.</p>\\n<p>When a user registers s/he will send some json containing email and password. In the end we will store password_hash in the db. For the hashing of the password we use <a href=\\\"https://github.com/elixircnx/comeonin\\\">comeonin</a>.</p>\\n<p>After we get the basics up and running, for example an endpoint that can take some post data and return a 200, we should modify the changeset method in the model to accept password and hide the password_hash.</p>\\n<p>Be sure to write tests for your code. To have your tests run as soon as you save a file you can use <a href=\\\"http://entrproject.org/\\\">entr</a>.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>while sleep 1; do ls -d lib/**/*.ex web/**/*.ex test/**/*.exs | entr│ mix test; done</code></pre>\\n      </div>\\n<h3>User Model</h3>\\n<p>We add a password field (virtual) to our model. That way we can pass it along from the user and convert it to a password_hash. We also change how the changeset works</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>schema \\\"users\\\" do\\n  field :email, :string\\n  field :password_hash, :string\\n  field :password, :string, virtual: true\\n\\n  timestamps\\nend\\n\\n@required_fields ~w(email password)\\n\\ndef changeset(model, params \\\\\\\\ :empty) do\\n  model\\n  |> cast(params, @required_fields, @optional_fields)\\n  |> unique_constraint(:email)\\n  |> validate_length(:password, min: 5)\\n  |> hash_password\\nend\\n\\ndefp hash_password(changeset) do\\n  if password = get_change(changeset, :password) do\\n    changeset\\n    |> put_change(:password_hash, hashpwsalt(password))\\n  else\\n    changeset\\n  end\\nend</code></pre>\\n      </div>\\n<p>We can test the password_hash in a model test:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>test \\\"password_hash value gets set to a hash\\\" do\\n  changeset = User.changeset(%User{}, @valid_attrs)\\n  assert Comeonin.Bcrypt.checkpw(@valid_attrs.password, Ecto.Changeset.get_change(changeset, :password_hash))\\nend</code></pre>\\n      </div>\\n<p>You will obviously have to write more and better tests then this for a real system.</p>\\n<p>Also, remember to change the view of users so it returns no password, or password_hash.</p>\\n<p>The controller code and tests in full. You will see features omitted, such as validations of emails etc.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>defmodule AppName.UserControllerTest do\\n  use AppName.ConnCase\\n\\n  alias AppName.User\\n  @valid_attrs %{email: \\\"some content\\\", password: \\\"validPassword\\\"}\\n  @invalid_attrs %{}\\n\\n  setup do\\n    conn = conn() |> put_req_header(\\\"accept\\\", \\\"application/json\\\")\\n    {:ok, conn: conn}\\n  end\\n\\n  test \\\"creates and renders resource when data is valid\\\", %{conn: conn} do\\n    conn = post conn, registration_path(conn, :create), user: @valid_attrs\\n    assert json_response(conn, 201)[\\\"data\\\"][\\\"id\\\"]\\n    assert Repo.get_by(User, email: @valid_attrs.email)\\n  end\\n\\n  test \\\"does not create resource and renders errors when data is invalid\\\", %{conn: conn} do\\n    conn = post conn, registration_path(conn, :create), user: @invalid_attrs\\n    assert json_response(conn, 422)[\\\"errors\\\"] != %{}\\n  end\\n\\n  test \\\"Users should have unique emails\\\", %{conn: conn} do\\n    post conn, registration_path(conn, :create), user: @valid_attrs\\n    conn = post conn, registration_path(conn, :create), user: @valid_attrs\\n    errors = json_response(conn, 422)[\\\"errors\\\"]\\n    assert errors != %{}\\n    assert Map.has_key?(errors, \\\"email\\\")\\n    assert Map.get(errors, \\\"email\\\") == [\\\"has already been taken\\\"]\\n  end\\nend</code></pre>\\n      </div>\\n<p>And the controller itself:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>defmodule AppName.RegistrationController do\\n  use AppName.Web, :controller\\n\\n  alias AppName.User\\n\\n  plug :scrub_params, \\\"user\\\" when action in [:create]\\n\\n  def create(conn, %{\\\"user\\\" => user_params}) do\\n    changeset = User.changeset(%User{}, user_params)\\n\\n    case Repo.insert(changeset) do\\n      {:ok, user} ->\\n        conn\\n        |> put_status(:created)\\n        |> render(AppName.UserView, \\\"show.json\\\", user: user)\\n      {:error, changeset} ->\\n        conn\\n        |> put_status(:unprocessable_entity)\\n        |> render(AppName.ChangesetView, \\\"error.json\\\", changeset: changeset)\\n    end\\n  end\\nend</code></pre>\\n      </div>\\n<p>Now we have something that allows us to create new users. Let´s enable Sign ins.</p>\\n<h2>Sign ins</h2>\\n<p>The user posts email and password, the server responds with 4xx if something went wrong. If the password matches the one stored in the database the server responds with 2xx and a Token.</p>\\n<p>Start by adding a new route</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>get \\\"/auth/login\\\", SessionController, :login</code></pre>\\n      </div>\\n<p>Create the controller and tests.</p>\\n<p>The tests will be something like this:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>defmodule AppName.SessionControllerTest do\\n  use AppName.ConnCase\\n\\n  alias AppName.User\\n  @valid_attrs %{email: \\\"some content\\\", password: \\\"validPassword\\\"}\\n  @invalid_attrs %{email: \\\"non-existing-user@example.com\\\", password: \\\"no-password\\\"}\\n\\n  setup do\\n    changeset = User.changeset(%User{}, @valid_attrs)\\n    {:ok, user} = Repo.insert changeset\\n    token = User.generate_token(user)\\n\\n    conn = conn() |> put_req_header(\\\"accept\\\", \\\"application/json\\\")\\n    {:ok, conn: conn, user: user, token: token}\\n  end\\n\\n  test \\\"Cannot authenticate a non existing user\\\", %{conn: conn} do\\n    conn = get conn, session_path(conn, :login), user: @invalid_attrs\\n    assert json_response(conn, 422)\\n  end\\n\\n  test \\\"Authenticate a valid user\\\", %{conn: conn} do\\n    conn = get conn, session_path(conn, :login), user: @valid_attrs\\n    assert json_response(conn, 200)[\\\"data\\\"][\\\"token\\\"] != nil\\n  end\\nend</code></pre>\\n      </div>\\n<p>The <code>generate_token</code> method is placed in the model to keep everything together, but could easily be placed in another file.</p>\\n<p>The controller for this looks </p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>defmodule AppName.SessionController do\\n  use AppName.Web, :controller\\n\\n  alias AppName.User\\n\\n  def login(conn, %{\\\"user\\\" => user_params}) do\\n    if user = Repo.get_by(User, email: user_params[\\\"email\\\"]) do\\n\\n      token = User.generate_token(user)\\n\\n      conn\\n      |> put_status(200)\\n      |> render(AppName.SessionView, \\\"session.json\\\", token: token)\\n    else\\n      conn\\n      |> put_status(:unprocessable_entity)\\n      |> render(AppName.SessionView, \\\"error.json\\\", message: \\\"Nope\\\")\\n    end\\n  end\\nend</code></pre>\\n      </div>\\n<p>We generate the token via a helper method in the model. It looks like this:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>def generate_token(user) do\\n  %{user_id: user.id}\\n  |> token\\n  |> with_signer(hs256(\\\"secret-change-me\\\"))\\n  |> sign\\n  |> get_compact\\nend</code></pre>\\n      </div>\\n<p>All the magic is <a href=\\\"https://github.com/bryanjos/joken\\\">Joken</a>, and you should read more about the options for it.</p>\\n<p>In short is contains the data on the second line (e.g. user_id: 1) but is signed so anyone with the secret can validate that the user is actually signed in without having to look up a random string token in the database. We can pass values such as the user id but also role: “admin” etc. We can use this later to get the current user for each request. Do not put anything secret in the claims part of the token, since it is readable by everyone.</p>\\n<p>Alright. That is it! We have a way to register user and a way to authenticate a user.</p>\\n<p>Now we only need to ensure that a unauthenticated user does not have access to thing s/he should not. This is the fun part.</p>\\n<h3>Validating an authenticated user</h3>\\n<p>We will define some routes that are protected, for this example we will do a <code>/auth/validate</code> that responds with 200 if the user is authenticated. If not the response will be <code>401, Unauthticated</code>.</p>\\n<p>We will use Mellon to parse the header and provide an interface to validate the token. With mellon the token can be anything, it just hands the data to any function you define and you can handle the validations yourself.</p>\\n<p>Check out <a href=\\\"https://github.com/sajmoon/mellon\\\">Mellon</a> for more information.</p>\\n<p>In your routes create a new pipeline and a route that is protected.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>pipeline :authenticated do\\n  plug Mellon, validator: {AppName.Validation, :validate, []}, header: \\\"api-token\\\"\\nend\\n\\nscope \\\"/api/\\\", AppName do\\n  pipe_through :api\\n  pipe_through :authenticated\\n  get \\\"/auth/validate\\\", SessionController, :validate\\nend</code></pre>\\n      </div>\\n<p>and the controller:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>def validate(conn, _params) do\\n  conn\\n  |> put_status(200)\\n  |> render(AppName.UserView, \\\"show.json\\\", user: %User{email: \\\"test\\\"})\\nend</code></pre>\\n      </div>\\n<p>The content to the view is temporary, and should probably be the user object itself.</p>\\n<p>To test this (before you add the <code>pipe_through :authenticated</code>) you can write some tests such as these:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>test \\\"validate token\\\", %{conn: conn, token: token} do\\n  conn = put_req_header(conn, \\\"api-token\\\", \\\"Token: \\\" <> token)\\n  conn = get conn, session_path(conn, :validate)\\n  assert json_response(conn, 200)\\nend\\n\\ntest \\\"validate fails if invalid token\\\", %{conn: conn} do\\n  conn = put_req_header(conn, \\\"api-token\\\", \\\"Token: invalid-token\\\")\\n  conn = get conn, session_path(conn, :validate)\\n  assert json_response(conn, 401)\\nend</code></pre>\\n      </div>\\n<p>You should see one or both fail.</p>\\n<p>The pipeline will pass all request through the Mellon Plug, which will call <code>AppName.Validation.validate/1</code> with the information needed to authenticate or reject the request.</p>\\n<p>The validate method gets the conn and token. We use a helper method in the model to verify the token, and then pass the claims (the information we put in the token: user_id: user.id) in the connection.\\nMellon will assign it to the connection so we can use it in the controller. Which is good for more granular access controller.</p>\\n<p>The validator looks like this.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>defmodule AppName.Validation do\\n  import Joken\\n  alias AppName.User\\n\\n  def validate({conn, token}) do\\n    User.verify_token(token)\\n    |> handle(conn)\\n  end\\n\\n  defp handle(%{error: nil, claims: claims}, conn) do\\n    {:ok, claims, conn}\\n  end\\n  defp handle(%{error: error}, conn) do\\n    {:error, [], conn}\\n  end\\nend</code></pre>\\n      </div>\\n<h2>Conclusion</h2>\\n<p>That it! We have a way to create users, authenticate users, and validate that the user is signed in with a valid token.</p>\\n<p>To do this we use <a href=\\\"https://github.com/sajmoon/mellon\\\">Mellon</a> to parse the headers, <a href=\\\"https://github.com/bryanjos/joken\\\">Joken</a> to create the token, and <a href=\\\"https://github.com/elixircnx/comeonin\\\">comeonin</a> to encrypt the password stored in the database.</p>\",\"frontmatter\":{\"title\":\"Elixir - Phoenix: Simple Authentication\",\"date\":\"January 02, 2016\"}}},\"pathContext\":{\"slug\":\"/2016-01-02-elixir-phoenix-simple-authentication/\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---2016-2016-01-02-elixir-phoenix-simple-authentication-c9818ddd92b6f348f55a.js","module.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Tinkering with Code.\",\"author\":\"Simon Ström\"}},\"markdownRemark\":{\"id\":\"/Users/simon/Code/sajmoon.github.io/src/pages/2016-01-02-elixir-phoenix-simple-authentication.md absPath of file >>> MarkdownRemark\",\"html\":\"<p>A simple Phoenix authentication flow for an JSON api. Using <a href=\\\"https://jwt.io/\\\">JSON Web Tokens</a> via <a href=\\\"https://github.com/bryanjos/joken\\\">Joken</a> and <a href=\\\"https://github.com/sajmoon/mellon\\\">Mellon</a> for access controller.</p>\\n<h2>The basics.</h2>\\n<p>Let’s start from scratch. Create a new Phoenix Application. Read the <a href=\\\"http://www.phoenixframework.org/docs/up-and-running\\\">Phoenix guide</a> to get started.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-sh\\\"><code>$ mix phoenix.new --no-brunch app_name\\n$ cd app_name\\n$ mix ecto.setup</code></pre>\\n      </div>\\n<h2>Create a user model</h2>\\n<p>We will use a generator now and remove most of the code, but obviously you don’t have to.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-sh\\\"><code>$ mix phoenix.gen.json User users email:string password_hash:string</code></pre>\\n      </div>\\n<p>We will want the emails to be unique so modify the migration file to include the following that will generate a index of all emails for us.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>create unique_index(:users, [:email])</code></pre>\\n      </div>\\n<p>We need to modify the routes, so let’s do that. We start by adding all possible CRUD routes in <code>web/routes.ex</code>.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>pipeline :api do\\n  plug :accepts, [\\\"json\\\"]\\nend\\n\\nscope \\\"/api/\\\" do\\n  pipe_through :api\\n  resources \\\"/users\\\", UserController\\nend</code></pre>\\n      </div>\\n<p>Then fix the database.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>$ mix ecto.migrate</code></pre>\\n      </div>\\n<p>We will not use the UserController but my memory is always messing with me and I need both the tests and controller to remember stuff.</p>\\n<h2>Registrate new users</h2>\\n<p>New users will <code>POST</code> to <code>/auth/</code> all data needed and a user will be created.</p>\\n<p>The route will be:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>scope \\\"/api/\\\" do\\n  pipe_through :api\\n  resources \\\"/users\\\", UserController\\n  \\n  post \\\"/auth\\\", RegistrationController, :create\\nend</code></pre>\\n      </div>\\n<p>So we need a new controller called <code>RegistrationController</code> located  in <code>web/controllers/registration_controller.ex</code>. The tests for that controller will be in <code>tests/controller/registration_controller_test.exs</code>. Create them both. See the full code further down.</p>\\n<p>When a user registers s/he will send some json containing email and password. In the end we will store password_hash in the db. For the hashing of the password we use <a href=\\\"https://github.com/elixircnx/comeonin\\\">comeonin</a>.</p>\\n<p>After we get the basics up and running, for example an endpoint that can take some post data and return a 200, we should modify the changeset method in the model to accept password and hide the password_hash.</p>\\n<p>Be sure to write tests for your code. To have your tests run as soon as you save a file you can use <a href=\\\"http://entrproject.org/\\\">entr</a>.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>while sleep 1; do ls -d lib/**/*.ex web/**/*.ex test/**/*.exs | entr│ mix test; done</code></pre>\\n      </div>\\n<h3>User Model</h3>\\n<p>We add a password field (virtual) to our model. That way we can pass it along from the user and convert it to a password_hash. We also change how the changeset works</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>schema \\\"users\\\" do\\n  field :email, :string\\n  field :password_hash, :string\\n  field :password, :string, virtual: true\\n\\n  timestamps\\nend\\n\\n@required_fields ~w(email password)\\n\\ndef changeset(model, params \\\\\\\\ :empty) do\\n  model\\n  |> cast(params, @required_fields, @optional_fields)\\n  |> unique_constraint(:email)\\n  |> validate_length(:password, min: 5)\\n  |> hash_password\\nend\\n\\ndefp hash_password(changeset) do\\n  if password = get_change(changeset, :password) do\\n    changeset\\n    |> put_change(:password_hash, hashpwsalt(password))\\n  else\\n    changeset\\n  end\\nend</code></pre>\\n      </div>\\n<p>We can test the password_hash in a model test:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>test \\\"password_hash value gets set to a hash\\\" do\\n  changeset = User.changeset(%User{}, @valid_attrs)\\n  assert Comeonin.Bcrypt.checkpw(@valid_attrs.password, Ecto.Changeset.get_change(changeset, :password_hash))\\nend</code></pre>\\n      </div>\\n<p>You will obviously have to write more and better tests then this for a real system.</p>\\n<p>Also, remember to change the view of users so it returns no password, or password_hash.</p>\\n<p>The controller code and tests in full. You will see features omitted, such as validations of emails etc.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>defmodule AppName.UserControllerTest do\\n  use AppName.ConnCase\\n\\n  alias AppName.User\\n  @valid_attrs %{email: \\\"some content\\\", password: \\\"validPassword\\\"}\\n  @invalid_attrs %{}\\n\\n  setup do\\n    conn = conn() |> put_req_header(\\\"accept\\\", \\\"application/json\\\")\\n    {:ok, conn: conn}\\n  end\\n\\n  test \\\"creates and renders resource when data is valid\\\", %{conn: conn} do\\n    conn = post conn, registration_path(conn, :create), user: @valid_attrs\\n    assert json_response(conn, 201)[\\\"data\\\"][\\\"id\\\"]\\n    assert Repo.get_by(User, email: @valid_attrs.email)\\n  end\\n\\n  test \\\"does not create resource and renders errors when data is invalid\\\", %{conn: conn} do\\n    conn = post conn, registration_path(conn, :create), user: @invalid_attrs\\n    assert json_response(conn, 422)[\\\"errors\\\"] != %{}\\n  end\\n\\n  test \\\"Users should have unique emails\\\", %{conn: conn} do\\n    post conn, registration_path(conn, :create), user: @valid_attrs\\n    conn = post conn, registration_path(conn, :create), user: @valid_attrs\\n    errors = json_response(conn, 422)[\\\"errors\\\"]\\n    assert errors != %{}\\n    assert Map.has_key?(errors, \\\"email\\\")\\n    assert Map.get(errors, \\\"email\\\") == [\\\"has already been taken\\\"]\\n  end\\nend</code></pre>\\n      </div>\\n<p>And the controller itself:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>defmodule AppName.RegistrationController do\\n  use AppName.Web, :controller\\n\\n  alias AppName.User\\n\\n  plug :scrub_params, \\\"user\\\" when action in [:create]\\n\\n  def create(conn, %{\\\"user\\\" => user_params}) do\\n    changeset = User.changeset(%User{}, user_params)\\n\\n    case Repo.insert(changeset) do\\n      {:ok, user} ->\\n        conn\\n        |> put_status(:created)\\n        |> render(AppName.UserView, \\\"show.json\\\", user: user)\\n      {:error, changeset} ->\\n        conn\\n        |> put_status(:unprocessable_entity)\\n        |> render(AppName.ChangesetView, \\\"error.json\\\", changeset: changeset)\\n    end\\n  end\\nend</code></pre>\\n      </div>\\n<p>Now we have something that allows us to create new users. Let´s enable Sign ins.</p>\\n<h2>Sign ins</h2>\\n<p>The user posts email and password, the server responds with 4xx if something went wrong. If the password matches the one stored in the database the server responds with 2xx and a Token.</p>\\n<p>Start by adding a new route</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>get \\\"/auth/login\\\", SessionController, :login</code></pre>\\n      </div>\\n<p>Create the controller and tests.</p>\\n<p>The tests will be something like this:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>defmodule AppName.SessionControllerTest do\\n  use AppName.ConnCase\\n\\n  alias AppName.User\\n  @valid_attrs %{email: \\\"some content\\\", password: \\\"validPassword\\\"}\\n  @invalid_attrs %{email: \\\"non-existing-user@example.com\\\", password: \\\"no-password\\\"}\\n\\n  setup do\\n    changeset = User.changeset(%User{}, @valid_attrs)\\n    {:ok, user} = Repo.insert changeset\\n    token = User.generate_token(user)\\n\\n    conn = conn() |> put_req_header(\\\"accept\\\", \\\"application/json\\\")\\n    {:ok, conn: conn, user: user, token: token}\\n  end\\n\\n  test \\\"Cannot authenticate a non existing user\\\", %{conn: conn} do\\n    conn = get conn, session_path(conn, :login), user: @invalid_attrs\\n    assert json_response(conn, 422)\\n  end\\n\\n  test \\\"Authenticate a valid user\\\", %{conn: conn} do\\n    conn = get conn, session_path(conn, :login), user: @valid_attrs\\n    assert json_response(conn, 200)[\\\"data\\\"][\\\"token\\\"] != nil\\n  end\\nend</code></pre>\\n      </div>\\n<p>The <code>generate_token</code> method is placed in the model to keep everything together, but could easily be placed in another file.</p>\\n<p>The controller for this looks </p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>defmodule AppName.SessionController do\\n  use AppName.Web, :controller\\n\\n  alias AppName.User\\n\\n  def login(conn, %{\\\"user\\\" => user_params}) do\\n    if user = Repo.get_by(User, email: user_params[\\\"email\\\"]) do\\n\\n      token = User.generate_token(user)\\n\\n      conn\\n      |> put_status(200)\\n      |> render(AppName.SessionView, \\\"session.json\\\", token: token)\\n    else\\n      conn\\n      |> put_status(:unprocessable_entity)\\n      |> render(AppName.SessionView, \\\"error.json\\\", message: \\\"Nope\\\")\\n    end\\n  end\\nend</code></pre>\\n      </div>\\n<p>We generate the token via a helper method in the model. It looks like this:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>def generate_token(user) do\\n  %{user_id: user.id}\\n  |> token\\n  |> with_signer(hs256(\\\"secret-change-me\\\"))\\n  |> sign\\n  |> get_compact\\nend</code></pre>\\n      </div>\\n<p>All the magic is <a href=\\\"https://github.com/bryanjos/joken\\\">Joken</a>, and you should read more about the options for it.</p>\\n<p>In short is contains the data on the second line (e.g. user_id: 1) but is signed so anyone with the secret can validate that the user is actually signed in without having to look up a random string token in the database. We can pass values such as the user id but also role: “admin” etc. We can use this later to get the current user for each request. Do not put anything secret in the claims part of the token, since it is readable by everyone.</p>\\n<p>Alright. That is it! We have a way to register user and a way to authenticate a user.</p>\\n<p>Now we only need to ensure that a unauthenticated user does not have access to thing s/he should not. This is the fun part.</p>\\n<h3>Validating an authenticated user</h3>\\n<p>We will define some routes that are protected, for this example we will do a <code>/auth/validate</code> that responds with 200 if the user is authenticated. If not the response will be <code>401, Unauthticated</code>.</p>\\n<p>We will use Mellon to parse the header and provide an interface to validate the token. With mellon the token can be anything, it just hands the data to any function you define and you can handle the validations yourself.</p>\\n<p>Check out <a href=\\\"https://github.com/sajmoon/mellon\\\">Mellon</a> for more information.</p>\\n<p>In your routes create a new pipeline and a route that is protected.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>pipeline :authenticated do\\n  plug Mellon, validator: {AppName.Validation, :validate, []}, header: \\\"api-token\\\"\\nend\\n\\nscope \\\"/api/\\\", AppName do\\n  pipe_through :api\\n  pipe_through :authenticated\\n  get \\\"/auth/validate\\\", SessionController, :validate\\nend</code></pre>\\n      </div>\\n<p>and the controller:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>def validate(conn, _params) do\\n  conn\\n  |> put_status(200)\\n  |> render(AppName.UserView, \\\"show.json\\\", user: %User{email: \\\"test\\\"})\\nend</code></pre>\\n      </div>\\n<p>The content to the view is temporary, and should probably be the user object itself.</p>\\n<p>To test this (before you add the <code>pipe_through :authenticated</code>) you can write some tests such as these:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>test \\\"validate token\\\", %{conn: conn, token: token} do\\n  conn = put_req_header(conn, \\\"api-token\\\", \\\"Token: \\\" <> token)\\n  conn = get conn, session_path(conn, :validate)\\n  assert json_response(conn, 200)\\nend\\n\\ntest \\\"validate fails if invalid token\\\", %{conn: conn} do\\n  conn = put_req_header(conn, \\\"api-token\\\", \\\"Token: invalid-token\\\")\\n  conn = get conn, session_path(conn, :validate)\\n  assert json_response(conn, 401)\\nend</code></pre>\\n      </div>\\n<p>You should see one or both fail.</p>\\n<p>The pipeline will pass all request through the Mellon Plug, which will call <code>AppName.Validation.validate/1</code> with the information needed to authenticate or reject the request.</p>\\n<p>The validate method gets the conn and token. We use a helper method in the model to verify the token, and then pass the claims (the information we put in the token: user_id: user.id) in the connection.\\nMellon will assign it to the connection so we can use it in the controller. Which is good for more granular access controller.</p>\\n<p>The validator looks like this.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>defmodule AppName.Validation do\\n  import Joken\\n  alias AppName.User\\n\\n  def validate({conn, token}) do\\n    User.verify_token(token)\\n    |> handle(conn)\\n  end\\n\\n  defp handle(%{error: nil, claims: claims}, conn) do\\n    {:ok, claims, conn}\\n  end\\n  defp handle(%{error: error}, conn) do\\n    {:error, [], conn}\\n  end\\nend</code></pre>\\n      </div>\\n<h2>Conclusion</h2>\\n<p>That it! We have a way to create users, authenticate users, and validate that the user is signed in with a valid token.</p>\\n<p>To do this we use <a href=\\\"https://github.com/sajmoon/mellon\\\">Mellon</a> to parse the headers, <a href=\\\"https://github.com/bryanjos/joken\\\">Joken</a> to create the token, and <a href=\\\"https://github.com/elixircnx/comeonin\\\">comeonin</a> to encrypt the password stored in the database.</p>\",\"frontmatter\":{\"title\":\"Elixir - Phoenix: Simple Authentication\",\"date\":\"January 02, 2016\"}}},\"pathContext\":{\"slug\":\"/2016-01-02-elixir-phoenix-simple-authentication/\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/2016-2016-01-02-elixir-phoenix-simple-authentication.json\n// module id = 528\n// module chunks = 275924165586894"],"sourceRoot":""}