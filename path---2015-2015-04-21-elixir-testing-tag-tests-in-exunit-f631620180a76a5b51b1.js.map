{"version":3,"sources":["webpack:///path---2015-2015-04-21-elixir-testing-tag-tests-in-exunit-f631620180a76a5b51b1.js","webpack:///./.cache/json/2015-2015-04-21-elixir-testing-tag-tests-in-exunit.json"],"names":["webpackJsonp","515","module","exports","data","site","siteMetadata","title","author","markdownRemark","id","html","frontmatter","date","pathContext","slug"],"mappings":"AAAAA,cAAc,gBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,MAAQC,cAAgBC,MAAA,uBAAAC,OAAA,gBAAuDC,gBAAmBC,GAAA,oIAAAC,KAAA,u/JAAm2IC,aAAy2BL,MAAA,uCAAAM,KAAA,oBAAyEC,aAAgBC,KAAA","file":"path---2015-2015-04-21-elixir-testing-tag-tests-in-exunit-f631620180a76a5b51b1.js","sourcesContent":["webpackJsonp([5588187674923],{\n\n/***/ 515:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Tinkering with Code.\",\"author\":\"Simon Ström\"}},\"markdownRemark\":{\"id\":\"/Users/simon/Code/sajmoon.github.io/src/pages/2015-04-21-elixir-testing-tag-tests-in-exunit.md absPath of file >>> MarkdownRemark\",\"html\":\"<p>Scope tests in ExUnit to reduce code duplication and have cleaner code.</p>\\n<p><strong>Update July 2016!</strong> This blog post is old, and things change. ExUnit now supports grouping with <code>describe</code>. Read more <a href=\\\"http://blog.simonstrom.xyz/grouping-tests-with-exunit-elixir/\\\">here</a>.</p>\\n<h2>Rspec nesting</h2>\\n<p>People with ruby, and rspec, background use <code>describe</code> to group tests that are similar or require the same setup. You can nest <code>describe</code> so all tests in the inner describe have the same setup.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>describe \\\"User\\\" do\\n  describe \\\".top\\\" do\\n    before { FactoryGirl.create_list(:user, 3) }\\n    it { expect(User.top(2)).to have(2).item }\\n  end\\nend</code></pre>\\n      </div>\\n<p>Example taken from <a href=\\\"http://betterspecs.org/\\\">betterspecs.org</a>.</p>\\n<p>This allows us to specify conditions (<code>before</code>) that are executed for all <code>it</code> inside <code>.top</code> but not any other specs.</p>\\n<p>Pretty handy.</p>\\n<h2>ExUnit @tag</h2>\\n<p>Elixirs ExUnit does not provide grouping tests in a module using a <code>dsl</code> like rspec. Instead we should use <code>@tag</code>.</p>\\n<p><code>@tag</code> is quite powerful.</p>\\n<h3>Timeout</h3>\\n<p>A first a simple example using tags.</p>\\n<p>Given we have a test we expect to fail due to a timeout running the test will take the default 3000ms to fail. Using tags we can change this using <code>@tag timeout: 30</code> and the test fails way faster.</p>\\n<h3>Excluding tests</h3>\\n<p>Assume we have lots of tests, some depending on an external api (not mocked) and some that do not depend on the service. Running all tests would take time. <strong>External APIs are slow by design.</strong> Or imagine the service is down/you do not have access to the a connection then the tests will always fail.</p>\\n<p>Failing tests are a pain when developing new features. <strong>Which failure is your fault?</strong> So to clean this up you only want to run tests that do not require an external source. This can be achived using <code>@tag</code>.</p>\\n<p>For each test requiring a network connection add the tag <code>external: true</code>, and when running the tests add <code>--exclude external</code>.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>mix test --exclude external\\nExcluding tags: [:external]\\n\\n...............\\n\\nFinished in 1.0 seconds (0.1s on load, 0.8s on tests)\\n15 tests, 0 failures</code></pre>\\n      </div>\\n<p>You could configure ExUnit to always exclude the external tag.\\nModify <code>test_helper.exs</code>:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>ExUnit.configure exclude: [external: true]\\nExUnit.start</code></pre>\\n      </div>\\n<p>When you want to run all tests use <code>--include external</code>.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>mix test --include external:true\\nIncluding tags: [external: \\\"true\\\"]\\nExcluding tags: [external: true]\\n\\n................\\n\\nFinished in 1.0 seconds (0.1s on load, 0.8s on tests)</code></pre>\\n      </div>\\n<h3>Grouping tests</h3>\\n<p>We start with an example:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>setup context do\\n  before(context)\\n  :ok\\nend\\n\\ndefp before(%{token: token}) do\\n  %Token{name: \\\"token1\\\", relic: token}\\n  |> Repo.insert\\nend\\n\\ndefp before(_params) do\\nend\\n     \\ntest \\\"assert no saved tokens\\\" do\\n  assert 0 == Repo.all(Token) |> Enum.count\\nend\\n\\n@tag token: \\\"A_TOKEN\\\"\\ntest \\\"assert one saved tokens\\\" do\\n  assert 1 == Repo.all(Token) |> Enum.count\\nend\\n\\n@tag token: \\\"MyToken\\\"\\ntest \\\"can access value from :token\\\", context do\\n  assert \\\"MyToken\\\" == context[:token]\\nend</code></pre>\\n      </div>\\n<p>Running these using mix</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>mix test\\n...\\nFinished in 0.1 seconds (0.07s on load, 0.1s on tests)\\n3 tests, 0 failures</code></pre>\\n      </div>\\n<p>Here we have 3 tests. The first one have no tag, and thus no Token. It has neither a token value, nor have it been saved to the persistence layer. The other tests use <code>@tag token: &#x3C;string></code> and thus the before clause matches, a token is stored and in the test we can access the token value. </p>\\n<p>To access the tag value we use <code>context</code>which is passed to the test as such <code>test \\\"some string\\\", context do</code>.</p>\\n<p>Ofcource we can use the token tag så exclude all tests that dependece on it.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>mix test --exclude token\\nExcluding tags: [:token]\\n.\\nFinished in 0.1 seconds (0.07s on load, 0.09s on tests)\\n1 tests, 0 failures</code></pre>\\n      </div>\\n<h3>Conclusion</h3>\\n<p>ExUnit <code>tag</code> is very nice. But I’d like to be able to group tests in a similar way as you can with rspec. I think its way easier to follow. Maybe that is just a simple little macro, but that is way over my head.</p>\\n<p>Happy coding.</p>\",\"frontmatter\":{\"title\":\"Elixir testing - Tag tests in ExUnit\",\"date\":\"April 21, 2015\"}}},\"pathContext\":{\"slug\":\"/2015-04-21-elixir-testing-tag-tests-in-exunit/\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---2015-2015-04-21-elixir-testing-tag-tests-in-exunit-f631620180a76a5b51b1.js","module.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Tinkering with Code.\",\"author\":\"Simon Ström\"}},\"markdownRemark\":{\"id\":\"/Users/simon/Code/sajmoon.github.io/src/pages/2015-04-21-elixir-testing-tag-tests-in-exunit.md absPath of file >>> MarkdownRemark\",\"html\":\"<p>Scope tests in ExUnit to reduce code duplication and have cleaner code.</p>\\n<p><strong>Update July 2016!</strong> This blog post is old, and things change. ExUnit now supports grouping with <code>describe</code>. Read more <a href=\\\"http://blog.simonstrom.xyz/grouping-tests-with-exunit-elixir/\\\">here</a>.</p>\\n<h2>Rspec nesting</h2>\\n<p>People with ruby, and rspec, background use <code>describe</code> to group tests that are similar or require the same setup. You can nest <code>describe</code> so all tests in the inner describe have the same setup.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>describe \\\"User\\\" do\\n  describe \\\".top\\\" do\\n    before { FactoryGirl.create_list(:user, 3) }\\n    it { expect(User.top(2)).to have(2).item }\\n  end\\nend</code></pre>\\n      </div>\\n<p>Example taken from <a href=\\\"http://betterspecs.org/\\\">betterspecs.org</a>.</p>\\n<p>This allows us to specify conditions (<code>before</code>) that are executed for all <code>it</code> inside <code>.top</code> but not any other specs.</p>\\n<p>Pretty handy.</p>\\n<h2>ExUnit @tag</h2>\\n<p>Elixirs ExUnit does not provide grouping tests in a module using a <code>dsl</code> like rspec. Instead we should use <code>@tag</code>.</p>\\n<p><code>@tag</code> is quite powerful.</p>\\n<h3>Timeout</h3>\\n<p>A first a simple example using tags.</p>\\n<p>Given we have a test we expect to fail due to a timeout running the test will take the default 3000ms to fail. Using tags we can change this using <code>@tag timeout: 30</code> and the test fails way faster.</p>\\n<h3>Excluding tests</h3>\\n<p>Assume we have lots of tests, some depending on an external api (not mocked) and some that do not depend on the service. Running all tests would take time. <strong>External APIs are slow by design.</strong> Or imagine the service is down/you do not have access to the a connection then the tests will always fail.</p>\\n<p>Failing tests are a pain when developing new features. <strong>Which failure is your fault?</strong> So to clean this up you only want to run tests that do not require an external source. This can be achived using <code>@tag</code>.</p>\\n<p>For each test requiring a network connection add the tag <code>external: true</code>, and when running the tests add <code>--exclude external</code>.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>mix test --exclude external\\nExcluding tags: [:external]\\n\\n...............\\n\\nFinished in 1.0 seconds (0.1s on load, 0.8s on tests)\\n15 tests, 0 failures</code></pre>\\n      </div>\\n<p>You could configure ExUnit to always exclude the external tag.\\nModify <code>test_helper.exs</code>:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>ExUnit.configure exclude: [external: true]\\nExUnit.start</code></pre>\\n      </div>\\n<p>When you want to run all tests use <code>--include external</code>.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>mix test --include external:true\\nIncluding tags: [external: \\\"true\\\"]\\nExcluding tags: [external: true]\\n\\n................\\n\\nFinished in 1.0 seconds (0.1s on load, 0.8s on tests)</code></pre>\\n      </div>\\n<h3>Grouping tests</h3>\\n<p>We start with an example:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>setup context do\\n  before(context)\\n  :ok\\nend\\n\\ndefp before(%{token: token}) do\\n  %Token{name: \\\"token1\\\", relic: token}\\n  |> Repo.insert\\nend\\n\\ndefp before(_params) do\\nend\\n     \\ntest \\\"assert no saved tokens\\\" do\\n  assert 0 == Repo.all(Token) |> Enum.count\\nend\\n\\n@tag token: \\\"A_TOKEN\\\"\\ntest \\\"assert one saved tokens\\\" do\\n  assert 1 == Repo.all(Token) |> Enum.count\\nend\\n\\n@tag token: \\\"MyToken\\\"\\ntest \\\"can access value from :token\\\", context do\\n  assert \\\"MyToken\\\" == context[:token]\\nend</code></pre>\\n      </div>\\n<p>Running these using mix</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>mix test\\n...\\nFinished in 0.1 seconds (0.07s on load, 0.1s on tests)\\n3 tests, 0 failures</code></pre>\\n      </div>\\n<p>Here we have 3 tests. The first one have no tag, and thus no Token. It has neither a token value, nor have it been saved to the persistence layer. The other tests use <code>@tag token: &#x3C;string></code> and thus the before clause matches, a token is stored and in the test we can access the token value. </p>\\n<p>To access the tag value we use <code>context</code>which is passed to the test as such <code>test \\\"some string\\\", context do</code>.</p>\\n<p>Ofcource we can use the token tag så exclude all tests that dependece on it.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-none\\\"><code>mix test --exclude token\\nExcluding tags: [:token]\\n.\\nFinished in 0.1 seconds (0.07s on load, 0.09s on tests)\\n1 tests, 0 failures</code></pre>\\n      </div>\\n<h3>Conclusion</h3>\\n<p>ExUnit <code>tag</code> is very nice. But I’d like to be able to group tests in a similar way as you can with rspec. I think its way easier to follow. Maybe that is just a simple little macro, but that is way over my head.</p>\\n<p>Happy coding.</p>\",\"frontmatter\":{\"title\":\"Elixir testing - Tag tests in ExUnit\",\"date\":\"April 21, 2015\"}}},\"pathContext\":{\"slug\":\"/2015-04-21-elixir-testing-tag-tests-in-exunit/\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/2015-2015-04-21-elixir-testing-tag-tests-in-exunit.json\n// module id = 515\n// module chunks = 5588187674923"],"sourceRoot":""}