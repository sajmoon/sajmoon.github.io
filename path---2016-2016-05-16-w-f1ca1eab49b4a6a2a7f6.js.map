{"version":3,"sources":["webpack:///path---2016-2016-05-16-w-f1ca1eab49b4a6a2a7f6.js","webpack:///./.cache/json/2016-2016-05-16-w.json"],"names":["webpackJsonp","531","module","exports","data","site","siteMetadata","title","author","markdownRemark","id","html","frontmatter","date","pathContext","slug"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,MAAQC,cAAgBC,MAAA,uBAAAC,OAAA,gBAAuDC,gBAAmBC,GAAA,mGAAAC,KAAA,g/KAAypHC,aAAmjEL,MAAA,iCAAAM,KAAA,kBAAiEC,aAAgBC,KAAA","file":"path---2016-2016-05-16-w-f1ca1eab49b4a6a2a7f6.js","sourcesContent":["webpackJsonp([159223139350163],{\n\n/***/ 531:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Tinkering with Code.\",\"author\":\"Simon Ström\"}},\"markdownRemark\":{\"id\":\"/Users/simon/Code/sajmoon.github.io/src/pages/2016-05-16-w.md absPath of file >>> MarkdownRemark\",\"html\":\"<p>I was playing around with a small phoenix app and wanted to embed some data in the model instead of of having an additional table.</p>\\n<p>I want one model called <code>Profile</code>. A profile should have some fields, and embed <code>address</code>.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-bash\\\"><code>mix phoenix.new {AppName}\\ncd {AppName}\\nmix test</code></pre>\\n      </div>\\n<p>That is your basic app. Now we need our profile, so let us generate it.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-bash\\\"><code>mix phoenix.gen.controller Profile profiles name:string email:string</code></pre>\\n      </div>\\n<p>This will give us a controller and a model, and some basic tests for it.</p>\\n<p>No we need to add our embedded model <code>address</code>. It will be stored in a jsonb column on the profile model.</p>\\n<p>In the end we want to be able to see the address from the show action on the ProfileController. So we modify the ProfileController#show to reflect the end result we want.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>test \\\"shows chosen resource\\\", %{conn: conn} do\\n    profile = Repo.insert! %Profile{}\\n    changeset = Ecto.Changeset.change(profile)\\n\\n    changeset = Ecto.Changeset.put_embed(changeset, :address,\\n      %Resume.Address{\\n        street: \\\"StreetName\\\",\\n        city: \\\"TheCityOfMyDreams\\\",\\n        zip: \\\"12345\\\",\\n        country: \\\"MyCountry\\\"\\n      }\\n    )\\n    Repo.update!(changeset)\\n\\n    conn = get conn, profile_path(conn, :show, profile)\\n    assert json_response(conn, 200)[\\\"data\\\"] == %{\\\"id\\\" => profile.id,\\n      \\\"name\\\" => profile.name,\\n      \\\"email\\\" => profile.email,\\n      \\\"address\\\" => %{\\n        \\\"city\\\" => \\\"TheCityOfMyDreams\\\",\\n        \\\"country\\\" => \\\"MyCountry\\\",\\n        \\\"street\\\" => \\\"StreetName\\\",\\n        \\\"zip\\\" => \\\"12345\\\",\\n      }\\n    }\\n  end</code></pre>\\n      </div>\\n<p>To set an address to our profile we use  Ecto.Changeset.put_embed/3. </p>\\n<p>The controller action does the correct thing; it fetches the profile and renders it. However, the rendering function does not by default include the address. To add it modify the profile view file.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>  def render(\\\"profile.json\\\", %{profile: profile}) do\\n    %{\\n      id: profile.id,\\n      name: profile.name,\\n      email: profile.email,\\n      address: render_one(profile.address, MyApp.AddressView, \\\"address.json\\\")\\n    }\\n  end</code></pre>\\n      </div>\\n<p>We call MyAppAddressView and asks it to render an address. So we need to implement it. Create <code>web/view/address_view.ex</code> with the following.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>defmodule MyApp.AddressView do\\n  use Resume.Web, :view\\n\\n  def render(\\\"address.json\\\", %{address: address}) do\\n    %{\\n      street: address.street,\\n      zip: address.zip,\\n      city: address.city,\\n      country: address.country\\n    }\\n  end\\nend</code></pre>\\n      </div>\\n<p>Cool!</p>\\n<p>Easy and explicit. Here we assume that profile.address is a valid thing. It should be embedded in the model.</p>\\n<p>The tests for it would be something like this:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code> test \\\"has embedded address\\\" do\\n    changeset = Profile.changeset(%Profile{}, @valid_attrs)\\n    changeset = Ecto.Changeset.put_embed(changeset, :address,\\n      %Resume.Address{ street: \\\"StreetName\\\" }\\n    )\\n\\n    assert changeset.changes.address.changes.street == \\\"StreetName\\\"\\n  end</code></pre>\\n      </div>\\n<p>It is a bit to explicit to check that the street name is correct, but it does the trick. Refactoring is your friend.</p>\\n<p>Now let us add address to profiles, and make this test pass.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>  schema \\\"profiles\\\" do\\n    field :name, :string\\n    field :email, :string\\n    embeds_one :address, MyApp.Address\\n\\n    timestamps\\n  end</code></pre>\\n      </div>\\n<p>We state that we want profiles to have ONE address, and we define an address to be MyApp.Address. Create a new model for it in <code>web/model/address.ex</code></p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>defmodule Resume.Address do\\n  use Ecto.Schema\\n\\n  embedded_schema do\\n    field :street, :string\\n    field :zip, :string\\n    field :city, :string\\n    field :country, :string\\n\\n    timestamps\\n  end\\nend</code></pre>\\n      </div>\\n<p>Nothing fancy. It just defines a schema. But for this to work, profiles needs a place to store it. We will add a <code>address</code> column in the <code>profile</code> table. It should be of type <code>jsonb</code>. We do that by setting it to a map.</p>\\n<p>Create a new migration</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>mix ecto.gen.migration AddAddressToProfile</code></pre>\\n      </div>\\n<p>Open the new file and add the migration</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>defmodule MyApp.Repo.Migrations.AddAddressToProfile do\\n  use Ecto.Migration\\n\\n  def change do\\n    alter table(:profiles) do\\n      add :address, :map\\n    end\\n  end\\nend</code></pre>\\n      </div>\\n<p>We use the type <code>map</code>.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-bash\\\"><code>mix ecto.create\\nmix ecto.migrate\\nmix test</code></pre>\\n      </div>\\n<p>It should all be green and pretty.</p>\",\"frontmatter\":{\"title\":\"Working Ecto embeds in Phoenix\",\"date\":\"May 15, 2016\"}}},\"pathContext\":{\"slug\":\"/2016-05-16-w/\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---2016-2016-05-16-w-f1ca1eab49b4a6a2a7f6.js","module.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Tinkering with Code.\",\"author\":\"Simon Ström\"}},\"markdownRemark\":{\"id\":\"/Users/simon/Code/sajmoon.github.io/src/pages/2016-05-16-w.md absPath of file >>> MarkdownRemark\",\"html\":\"<p>I was playing around with a small phoenix app and wanted to embed some data in the model instead of of having an additional table.</p>\\n<p>I want one model called <code>Profile</code>. A profile should have some fields, and embed <code>address</code>.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-bash\\\"><code>mix phoenix.new {AppName}\\ncd {AppName}\\nmix test</code></pre>\\n      </div>\\n<p>That is your basic app. Now we need our profile, so let us generate it.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-bash\\\"><code>mix phoenix.gen.controller Profile profiles name:string email:string</code></pre>\\n      </div>\\n<p>This will give us a controller and a model, and some basic tests for it.</p>\\n<p>No we need to add our embedded model <code>address</code>. It will be stored in a jsonb column on the profile model.</p>\\n<p>In the end we want to be able to see the address from the show action on the ProfileController. So we modify the ProfileController#show to reflect the end result we want.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>test \\\"shows chosen resource\\\", %{conn: conn} do\\n    profile = Repo.insert! %Profile{}\\n    changeset = Ecto.Changeset.change(profile)\\n\\n    changeset = Ecto.Changeset.put_embed(changeset, :address,\\n      %Resume.Address{\\n        street: \\\"StreetName\\\",\\n        city: \\\"TheCityOfMyDreams\\\",\\n        zip: \\\"12345\\\",\\n        country: \\\"MyCountry\\\"\\n      }\\n    )\\n    Repo.update!(changeset)\\n\\n    conn = get conn, profile_path(conn, :show, profile)\\n    assert json_response(conn, 200)[\\\"data\\\"] == %{\\\"id\\\" => profile.id,\\n      \\\"name\\\" => profile.name,\\n      \\\"email\\\" => profile.email,\\n      \\\"address\\\" => %{\\n        \\\"city\\\" => \\\"TheCityOfMyDreams\\\",\\n        \\\"country\\\" => \\\"MyCountry\\\",\\n        \\\"street\\\" => \\\"StreetName\\\",\\n        \\\"zip\\\" => \\\"12345\\\",\\n      }\\n    }\\n  end</code></pre>\\n      </div>\\n<p>To set an address to our profile we use  Ecto.Changeset.put_embed/3. </p>\\n<p>The controller action does the correct thing; it fetches the profile and renders it. However, the rendering function does not by default include the address. To add it modify the profile view file.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>  def render(\\\"profile.json\\\", %{profile: profile}) do\\n    %{\\n      id: profile.id,\\n      name: profile.name,\\n      email: profile.email,\\n      address: render_one(profile.address, MyApp.AddressView, \\\"address.json\\\")\\n    }\\n  end</code></pre>\\n      </div>\\n<p>We call MyAppAddressView and asks it to render an address. So we need to implement it. Create <code>web/view/address_view.ex</code> with the following.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>defmodule MyApp.AddressView do\\n  use Resume.Web, :view\\n\\n  def render(\\\"address.json\\\", %{address: address}) do\\n    %{\\n      street: address.street,\\n      zip: address.zip,\\n      city: address.city,\\n      country: address.country\\n    }\\n  end\\nend</code></pre>\\n      </div>\\n<p>Cool!</p>\\n<p>Easy and explicit. Here we assume that profile.address is a valid thing. It should be embedded in the model.</p>\\n<p>The tests for it would be something like this:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code> test \\\"has embedded address\\\" do\\n    changeset = Profile.changeset(%Profile{}, @valid_attrs)\\n    changeset = Ecto.Changeset.put_embed(changeset, :address,\\n      %Resume.Address{ street: \\\"StreetName\\\" }\\n    )\\n\\n    assert changeset.changes.address.changes.street == \\\"StreetName\\\"\\n  end</code></pre>\\n      </div>\\n<p>It is a bit to explicit to check that the street name is correct, but it does the trick. Refactoring is your friend.</p>\\n<p>Now let us add address to profiles, and make this test pass.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>  schema \\\"profiles\\\" do\\n    field :name, :string\\n    field :email, :string\\n    embeds_one :address, MyApp.Address\\n\\n    timestamps\\n  end</code></pre>\\n      </div>\\n<p>We state that we want profiles to have ONE address, and we define an address to be MyApp.Address. Create a new model for it in <code>web/model/address.ex</code></p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>defmodule Resume.Address do\\n  use Ecto.Schema\\n\\n  embedded_schema do\\n    field :street, :string\\n    field :zip, :string\\n    field :city, :string\\n    field :country, :string\\n\\n    timestamps\\n  end\\nend</code></pre>\\n      </div>\\n<p>Nothing fancy. It just defines a schema. But for this to work, profiles needs a place to store it. We will add a <code>address</code> column in the <code>profile</code> table. It should be of type <code>jsonb</code>. We do that by setting it to a map.</p>\\n<p>Create a new migration</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>mix ecto.gen.migration AddAddressToProfile</code></pre>\\n      </div>\\n<p>Open the new file and add the migration</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>defmodule MyApp.Repo.Migrations.AddAddressToProfile do\\n  use Ecto.Migration\\n\\n  def change do\\n    alter table(:profiles) do\\n      add :address, :map\\n    end\\n  end\\nend</code></pre>\\n      </div>\\n<p>We use the type <code>map</code>.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-bash\\\"><code>mix ecto.create\\nmix ecto.migrate\\nmix test</code></pre>\\n      </div>\\n<p>It should all be green and pretty.</p>\",\"frontmatter\":{\"title\":\"Working Ecto embeds in Phoenix\",\"date\":\"May 15, 2016\"}}},\"pathContext\":{\"slug\":\"/2016-05-16-w/\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/2016-2016-05-16-w.json\n// module id = 531\n// module chunks = 159223139350163"],"sourceRoot":""}