{"version":3,"sources":["webpack:///path---2015-2015-10-25-playing-around-with-elixir-processes-380800d934ee66e71228.js","webpack:///./.cache/json/2015-2015-10-25-playing-around-with-elixir-processes.json"],"names":["webpackJsonp","528","module","exports","data","site","siteMetadata","title","author","markdownRemark","id","html","frontmatter","date","pathContext","slug"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,MAAQC,cAAgBC,MAAA,uBAAAC,OAAA,gBAAuDC,gBAAmBC,GAAA,sIAAAC,KAAA,+2XAA45XC,aAA8ML,MAAA,qCAAAM,KAAA,sBAAyEC,aAAgBC,KAAA","file":"path---2015-2015-10-25-playing-around-with-elixir-processes-380800d934ee66e71228.js","sourcesContent":["webpackJsonp([138779859493271],{\n\n/***/ 528:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Tinkering with Code.\",\"author\":\"Simon Ström\"}},\"markdownRemark\":{\"id\":\"/Users/simon/Code/sajmoon.github.io/src/pages/2015-10-25-playing-around-with-elixir-processes.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>Elixir and Process</h1>\\n<p>In Erlang and Elixir we talk about process the way you would talk about threads in some other language. They are not system process. You cannot see them using <code>ps</code> or <code>top</code>. They are managed and created by the Erlang VM.</p>\\n<p>And the Erlang VM is pretty good at managing them.</p>\\n<h2>Create a process</h2>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>iex(1)> pid = spawn(fn -> IO.puts \\\"im alive\\\" end)\\nim alive\\n#PID<0.61.0>\\n\\niex(3)> Process.alive? pid\\nfalse</code></pre>\\n      </div>\\n<p>So we spawned a process with the job to execute the anonymous function we passed to it, and then it quit.\\nCool. What else can we do?</p>\\n<h2>Why send messages?</h2>\\n<p>A big part of what makes the Erlang concurrency model so great is the use of messages. By starting a processes to do one thing and then communicate with that process through messages you have built a system that scales very easily to be global. We don’t really care that the process we are sending a message to is a local process. It could just as easily be in some datacenter on the other side of the world. No worries. We build a system ready to be scaled.</p>\\n<h2>How to send messages.</h2>\\n<p>A message is sent either to a <code>pid</code>(process id) or to a named process. Lets start by sending messages to a pid.</p>\\n<p>Start iex.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>iex(1)> self\\n#PID<0.57.0>\\niex(2)> send(self, \\\"hello\\\")\\n\\\"hello\\\"\\niex(3)> flush\\n\\\"hello\\\"\\n:ok</code></pre>\\n      </div>\\n<p>Self returns the pid of the process we are in now. In this case iex itself.\\nSend takes two parameters, a <code>pid</code> and the message.\\nWe have not yet configured our process to listen for messages, but a short hand is to <code>flush</code> the mailbox for the current process. That will list all messages received.</p>\\n<p>Alright. Sending and flushing all done.</p>\\n<h2>Receiving messages</h2>\\n<p>So if processes talks through messages we need a way to send and listen to messages that is being sent around.</p>\\n<p>Let’s create a small <code>Worker</code> process. Create a file called <code>processes.ex</code>.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>defmodule ElixirTest.BasicWorker do\\n  def loop do\\n    receive do\\n      {sender_pid, _} ->\\n        send(sender_pid, {:ok, :pong})\\n        loop\\n    end\\n  end\\nend</code></pre>\\n      </div>\\n<p>It is just a echo service.</p>\\n<p>How to use it then?</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>iex(1)> c(\\\"processes.ex\\\")</code></pre>\\n      </div>\\n<p>Compiles the file so we can use the modules from iex. Then spawn a process. Remember to save the pid.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>iex(2)> pid = spawn(ElixirTest.BasicWorker, :loop, [])\\n#PID<0.74.0></code></pre>\\n      </div>\\n<p>After that send a message to it and check the <code>mail box</code>, lacking a better term.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>iex(3)> send(pid, {self, :ok})\\n{#PID<0.57.0>, :ok}\\niex(4)> flush\\n{:ok, :pong}\\n:ok</code></pre>\\n      </div>\\n<p>Awesome. Our process replied. We could just keep on sending messages.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>iex(18)> send(pid, {self, :ok})\\n{#PID<0.57.0>, :ok}\\niex(19)> send(pid, {self, :ok})\\n{#PID<0.57.0>, :ok}\\niex(20)> flush\\n{:ok, :pong}\\n{:ok, :pong}\\n:ok</code></pre>\\n      </div>\\n<p>And since everything Elixir is pattern matching we could send very specific messages.</p>\\n<h2>What about async?</h2>\\n<p>What processing a message takes some time? Think a costly http request or some calculations, will the iex prompt freeze? Let’s see.</p>\\n<p>Modify your worker to include a delay to simulate some heavy work.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>defmodule ElixirTest.BasicWorker do\\n  def loop do\\n    receive do\\n      {sender_pid, _} ->\\n        :timer.sleep(1000)\\n        send(sender_pid, {:ok, :pong})\\n        loop\\n    end\\n  end\\nend</code></pre>\\n      </div>\\n<p>Reload or recompile the module.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>iex(21)> r(ElixirTest.BasicWorker)</code></pre>\\n      </div>\\n<p>And try it out!</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>iex(26)> send(pid, {self, :ok})\\n{#PID<0.57.0>, :ok}\\niex(27)> flush\\n:ok\\niex(28)> flush\\n{:ok, :pong}\\n:ok</code></pre>\\n      </div>\\n<p>The first flush has not received any message from your process but still you are free to keep on doing stuff.</p>\\n<p>This is not weird or anything special. <code>send</code> have to be async, otherwise whats the point? But it’s good to be sure.</p>\\n<h2>Sending messages to a dead process</h2>\\n<p>Everything dies. So how would send behave if the process died?</p>\\n<p>Let us kill it.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>iex(31)> Process.exit(pid, :kill)\\ntrue\\niex(32)> Process.alive? pid\\nfalse\\niex(33)> send(pid, {self, :ok})\\n{#PID<0.57.0>, :ok}</code></pre>\\n      </div>\\n<p>We can still send messages. <code>send</code> doesn’t wait for a replie so if the process is listening or not doesn’t really matter.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>iex(35)> flush\\n:ok</code></pre>\\n      </div>\\n<p>After a flush we can see that nothing has been sent to our iex process. Well, the worker is dead so that is to be expected.</p>\\n<h2>Kill iex</h2>\\n<p>Iex, our interactive elixir console, is just a process as anything else. We know the pid. So we can do stuff with it, like kill it.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>iex(40)> self\\n#PID<0.57.0>\\niex(41)> Process.exit(self, :exit)\\n** (EXIT from #PID<0.57.0>) :exit\\n\\nInteractive Elixir (1.1.1) - press Ctrl+C to exit (type h() ENTER for help)\\niex(1)> self\\n#PID<0.23081.0></code></pre>\\n      </div>\\n<p>It restarted it self.</p>\\n<p>That is not true, but it was restarted. We got a new pid, so it is not the same process.</p>\\n<p>The iex is part of an application, which has a supervisor. Supervisors have one job, and that is to handle crashed processes. We can see our current supervisor tree and the applications running on our BEAM.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>iex(4)> :observer.start\\n:ok</code></pre>\\n      </div>\\n<p>A gui application will start, where you can browse around and do stuff.</p>\\n<p>Click the tab Applications and you will see iex listed to the left. The graph shows the tree of processes for that application.</p>\\n<p>You will see a Supervisor. Klick on that blob and in the menu select Kill. You will see it does not come back.</p>\\n<p>In the running iex we see a message:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>iex(5)>\\n23:21:16.631 [info]  Application iex exited: killed</code></pre>\\n      </div>\\n<p>Killed and closed.</p>\\n<h3>What do we know about our process?</h3>\\n<p>Restart iex and spawn one of our small workers. We will use <code>Process.info</code> to learn something about it.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>iex(2)> pid = spawn(ElixirTest.BasicWorker, :loop, [])\\n#PID<0.68.0>\\niex(3)> self\\n#PID<0.57.0>\\niex(4)> Process.info(pid)\\n[current_function: {ElixirTest.BasicWorker, :loop, 0},\\n initial_call: {ElixirTest.BasicWorker, :loop, 0}, status: :waiting,\\n message_queue_len: 0, messages: [], links: [], dictionary: [],\\n trap_exit: false, error_handler: :error_handler, priority: :normal,\\n group_leader: #PID<0.26.0>, total_heap_size: 233, heap_size: 233,\\n stack_size: 2, reductions: 1,\\n garbage_collection: [min_bin_vheap_size: 46422, min_heap_size: 233,\\n  fullsweep_after: 65535, minor_gcs: 0], suspending: []]</code></pre>\\n      </div>\\n<p>Lots of information! We can see what the process is doing right now with the <code>current_function</code> and <code>status</code>. We can see messageges waiting to be processed. We can see the <strong>heap size</strong> and more memory information.</p>\\n<p>Set the delay in our worker to something long, 20 seconds or so. Send 4 messages or so to the process. Check the info now.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>iex(10)> send(pid, {self, :ping})\\n{#PID<0.57.0>, :ping}\\niex(11)> send(pid, {self, :ping})\\n{#PID<0.57.0>, :ping}\\niex(12)> send(pid, {self, :ping})\\n{#PID<0.57.0>, :ping}\\niex(13)> send(pid, {self, :ping})\\n{#PID<0.57.0>, :ping}\\niex(14)> send(pid, {self, :ping})\\n{#PID<0.57.0>, :ping}\\niex(15)> Process.info(pid)\\n[current_function: {:timer, :sleep, 1},\\n initial_call: {ElixirTest.BasicWorker, :loop, 0}, status: :waiting,\\n message_queue_len: 4,\\n messages: [{#PID<0.57.0>, :ping}, {#PID<0.57.0>, :ping}, {#PID<0.57.0>, :ping},\\n  {#PID<0.57.0>, :ping}], links: [], dictionary: [], trap_exit: false,\\n error_handler: :error_handler, priority: :normal, group_leader: #PID<0.26.0>,\\n total_heap_size: 233, heap_size: 233, stack_size: 4, reductions: 5,\\n garbage_collection: [min_bin_vheap_size: 46422, min_heap_size: 233,\\n  fullsweep_after: 65535, minor_gcs: 0], suspending: []]</code></pre>\\n      </div>\\n<p>The process now have <strong><em>message</em>queue_len: 4</strong>, meaning it has messages waiting. Since the process only handles one message at a time, the messages to iex will come at 20seconds intervals.</p>\\n<h3>Parallell process</h3>\\n<p>So we found a problem. Our worker is async. But it does not do work in parallell. This will definitely be a problem. To solve this we create a server which only has one job. Listen to messages, and for each message start a worker process that handles the heavy calculations (:timer.sleep in our case).</p>\\n<p>Show me some code!</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>defmodule ElixirTest.BasicWorker do\\n  def execute sender_pid do\\n    :timer.sleep(10000)\\n    send(sender_pid, {:ok, :pong})\\n  end\\nend\\n\\ndefmodule ElixirTest.BasicServer do\\n  def loop do\\n    receive do\\n      {sender_pid, _} ->\\n        worker_pid = spawn(ElixirTest.BasicWorker, :execute, [sender_pid])\\n        loop\\n    end\\n  end\\nend</code></pre>\\n      </div>\\n<p>For each message the server spawns a worker that does all the calculations and after sends a message to our iex pid.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>iex(7)> send(server_pid, {self, :ping})\\n{#PID<0.57.0>, :ping}\\niex(8)> send(server_pid, {self, :ping})\\n{#PID<0.57.0>, :ping}\\niex(9)> send(server_pid, {self, :ping})\\n{#PID<0.57.0>, :ping}\\niex(10)> send(server_pid, {self, :ping})\\n{#PID<0.57.0>, :ping}\\niex(11)> Process.info(server_pid)\\n[current_function: {ElixirTest.BasicServer, :loop, 0},\\n initial_call: {ElixirTest.BasicServer, :loop, 0}, status: :waiting,\\n message_queue_len: 0, messages: [], links: [], dictionary: [],\\n trap_exit: false, error_handler: :error_handler, priority: :normal,\\n group_leader: #PID<0.26.0>, total_heap_size: 233, heap_size: 233,\\n stack_size: 1, reductions: 1149,\\n garbage_collection: [min_bin_vheap_size: 46422, min_heap_size: 233,\\n  fullsweep_after: 65535, minor_gcs: 0], suspending: []]\\niex(12)> flush\\n:ok</code></pre>\\n      </div>\\n<p>No messages in the queue. All have been processed. Or started at least. We still haven’t received any messages. Wait around 10 seconds and the messages should start to come in.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>ex(15)> flush\\n{:ok, :pong}\\n{:ok, :pong}\\n:ok</code></pre>\\n      </div>\\n<p>Cool. So we built a async worker, which didn’t do any work in parallel. Then we modified it with a dispatcher and it got some parallel super powers.</p>\",\"frontmatter\":{\"title\":\"Playing around with Elixir Process\",\"date\":\"October 25, 2015\"}}},\"pathContext\":{\"slug\":\"/2015-10-25-playing-around-with-elixir-processes/\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---2015-2015-10-25-playing-around-with-elixir-processes-380800d934ee66e71228.js","module.exports = {\"data\":{\"site\":{\"siteMetadata\":{\"title\":\"Tinkering with Code.\",\"author\":\"Simon Ström\"}},\"markdownRemark\":{\"id\":\"/Users/simon/Code/sajmoon.github.io/src/pages/2015-10-25-playing-around-with-elixir-processes.md absPath of file >>> MarkdownRemark\",\"html\":\"<h1>Elixir and Process</h1>\\n<p>In Erlang and Elixir we talk about process the way you would talk about threads in some other language. They are not system process. You cannot see them using <code>ps</code> or <code>top</code>. They are managed and created by the Erlang VM.</p>\\n<p>And the Erlang VM is pretty good at managing them.</p>\\n<h2>Create a process</h2>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>iex(1)> pid = spawn(fn -> IO.puts \\\"im alive\\\" end)\\nim alive\\n#PID<0.61.0>\\n\\niex(3)> Process.alive? pid\\nfalse</code></pre>\\n      </div>\\n<p>So we spawned a process with the job to execute the anonymous function we passed to it, and then it quit.\\nCool. What else can we do?</p>\\n<h2>Why send messages?</h2>\\n<p>A big part of what makes the Erlang concurrency model so great is the use of messages. By starting a processes to do one thing and then communicate with that process through messages you have built a system that scales very easily to be global. We don’t really care that the process we are sending a message to is a local process. It could just as easily be in some datacenter on the other side of the world. No worries. We build a system ready to be scaled.</p>\\n<h2>How to send messages.</h2>\\n<p>A message is sent either to a <code>pid</code>(process id) or to a named process. Lets start by sending messages to a pid.</p>\\n<p>Start iex.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>iex(1)> self\\n#PID<0.57.0>\\niex(2)> send(self, \\\"hello\\\")\\n\\\"hello\\\"\\niex(3)> flush\\n\\\"hello\\\"\\n:ok</code></pre>\\n      </div>\\n<p>Self returns the pid of the process we are in now. In this case iex itself.\\nSend takes two parameters, a <code>pid</code> and the message.\\nWe have not yet configured our process to listen for messages, but a short hand is to <code>flush</code> the mailbox for the current process. That will list all messages received.</p>\\n<p>Alright. Sending and flushing all done.</p>\\n<h2>Receiving messages</h2>\\n<p>So if processes talks through messages we need a way to send and listen to messages that is being sent around.</p>\\n<p>Let’s create a small <code>Worker</code> process. Create a file called <code>processes.ex</code>.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>defmodule ElixirTest.BasicWorker do\\n  def loop do\\n    receive do\\n      {sender_pid, _} ->\\n        send(sender_pid, {:ok, :pong})\\n        loop\\n    end\\n  end\\nend</code></pre>\\n      </div>\\n<p>It is just a echo service.</p>\\n<p>How to use it then?</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>iex(1)> c(\\\"processes.ex\\\")</code></pre>\\n      </div>\\n<p>Compiles the file so we can use the modules from iex. Then spawn a process. Remember to save the pid.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>iex(2)> pid = spawn(ElixirTest.BasicWorker, :loop, [])\\n#PID<0.74.0></code></pre>\\n      </div>\\n<p>After that send a message to it and check the <code>mail box</code>, lacking a better term.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>iex(3)> send(pid, {self, :ok})\\n{#PID<0.57.0>, :ok}\\niex(4)> flush\\n{:ok, :pong}\\n:ok</code></pre>\\n      </div>\\n<p>Awesome. Our process replied. We could just keep on sending messages.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>iex(18)> send(pid, {self, :ok})\\n{#PID<0.57.0>, :ok}\\niex(19)> send(pid, {self, :ok})\\n{#PID<0.57.0>, :ok}\\niex(20)> flush\\n{:ok, :pong}\\n{:ok, :pong}\\n:ok</code></pre>\\n      </div>\\n<p>And since everything Elixir is pattern matching we could send very specific messages.</p>\\n<h2>What about async?</h2>\\n<p>What processing a message takes some time? Think a costly http request or some calculations, will the iex prompt freeze? Let’s see.</p>\\n<p>Modify your worker to include a delay to simulate some heavy work.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>defmodule ElixirTest.BasicWorker do\\n  def loop do\\n    receive do\\n      {sender_pid, _} ->\\n        :timer.sleep(1000)\\n        send(sender_pid, {:ok, :pong})\\n        loop\\n    end\\n  end\\nend</code></pre>\\n      </div>\\n<p>Reload or recompile the module.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>iex(21)> r(ElixirTest.BasicWorker)</code></pre>\\n      </div>\\n<p>And try it out!</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>iex(26)> send(pid, {self, :ok})\\n{#PID<0.57.0>, :ok}\\niex(27)> flush\\n:ok\\niex(28)> flush\\n{:ok, :pong}\\n:ok</code></pre>\\n      </div>\\n<p>The first flush has not received any message from your process but still you are free to keep on doing stuff.</p>\\n<p>This is not weird or anything special. <code>send</code> have to be async, otherwise whats the point? But it’s good to be sure.</p>\\n<h2>Sending messages to a dead process</h2>\\n<p>Everything dies. So how would send behave if the process died?</p>\\n<p>Let us kill it.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>iex(31)> Process.exit(pid, :kill)\\ntrue\\niex(32)> Process.alive? pid\\nfalse\\niex(33)> send(pid, {self, :ok})\\n{#PID<0.57.0>, :ok}</code></pre>\\n      </div>\\n<p>We can still send messages. <code>send</code> doesn’t wait for a replie so if the process is listening or not doesn’t really matter.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>iex(35)> flush\\n:ok</code></pre>\\n      </div>\\n<p>After a flush we can see that nothing has been sent to our iex process. Well, the worker is dead so that is to be expected.</p>\\n<h2>Kill iex</h2>\\n<p>Iex, our interactive elixir console, is just a process as anything else. We know the pid. So we can do stuff with it, like kill it.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>iex(40)> self\\n#PID<0.57.0>\\niex(41)> Process.exit(self, :exit)\\n** (EXIT from #PID<0.57.0>) :exit\\n\\nInteractive Elixir (1.1.1) - press Ctrl+C to exit (type h() ENTER for help)\\niex(1)> self\\n#PID<0.23081.0></code></pre>\\n      </div>\\n<p>It restarted it self.</p>\\n<p>That is not true, but it was restarted. We got a new pid, so it is not the same process.</p>\\n<p>The iex is part of an application, which has a supervisor. Supervisors have one job, and that is to handle crashed processes. We can see our current supervisor tree and the applications running on our BEAM.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>iex(4)> :observer.start\\n:ok</code></pre>\\n      </div>\\n<p>A gui application will start, where you can browse around and do stuff.</p>\\n<p>Click the tab Applications and you will see iex listed to the left. The graph shows the tree of processes for that application.</p>\\n<p>You will see a Supervisor. Klick on that blob and in the menu select Kill. You will see it does not come back.</p>\\n<p>In the running iex we see a message:</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>iex(5)>\\n23:21:16.631 [info]  Application iex exited: killed</code></pre>\\n      </div>\\n<p>Killed and closed.</p>\\n<h3>What do we know about our process?</h3>\\n<p>Restart iex and spawn one of our small workers. We will use <code>Process.info</code> to learn something about it.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>iex(2)> pid = spawn(ElixirTest.BasicWorker, :loop, [])\\n#PID<0.68.0>\\niex(3)> self\\n#PID<0.57.0>\\niex(4)> Process.info(pid)\\n[current_function: {ElixirTest.BasicWorker, :loop, 0},\\n initial_call: {ElixirTest.BasicWorker, :loop, 0}, status: :waiting,\\n message_queue_len: 0, messages: [], links: [], dictionary: [],\\n trap_exit: false, error_handler: :error_handler, priority: :normal,\\n group_leader: #PID<0.26.0>, total_heap_size: 233, heap_size: 233,\\n stack_size: 2, reductions: 1,\\n garbage_collection: [min_bin_vheap_size: 46422, min_heap_size: 233,\\n  fullsweep_after: 65535, minor_gcs: 0], suspending: []]</code></pre>\\n      </div>\\n<p>Lots of information! We can see what the process is doing right now with the <code>current_function</code> and <code>status</code>. We can see messageges waiting to be processed. We can see the <strong>heap size</strong> and more memory information.</p>\\n<p>Set the delay in our worker to something long, 20 seconds or so. Send 4 messages or so to the process. Check the info now.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>iex(10)> send(pid, {self, :ping})\\n{#PID<0.57.0>, :ping}\\niex(11)> send(pid, {self, :ping})\\n{#PID<0.57.0>, :ping}\\niex(12)> send(pid, {self, :ping})\\n{#PID<0.57.0>, :ping}\\niex(13)> send(pid, {self, :ping})\\n{#PID<0.57.0>, :ping}\\niex(14)> send(pid, {self, :ping})\\n{#PID<0.57.0>, :ping}\\niex(15)> Process.info(pid)\\n[current_function: {:timer, :sleep, 1},\\n initial_call: {ElixirTest.BasicWorker, :loop, 0}, status: :waiting,\\n message_queue_len: 4,\\n messages: [{#PID<0.57.0>, :ping}, {#PID<0.57.0>, :ping}, {#PID<0.57.0>, :ping},\\n  {#PID<0.57.0>, :ping}], links: [], dictionary: [], trap_exit: false,\\n error_handler: :error_handler, priority: :normal, group_leader: #PID<0.26.0>,\\n total_heap_size: 233, heap_size: 233, stack_size: 4, reductions: 5,\\n garbage_collection: [min_bin_vheap_size: 46422, min_heap_size: 233,\\n  fullsweep_after: 65535, minor_gcs: 0], suspending: []]</code></pre>\\n      </div>\\n<p>The process now have <strong><em>message</em>queue_len: 4</strong>, meaning it has messages waiting. Since the process only handles one message at a time, the messages to iex will come at 20seconds intervals.</p>\\n<h3>Parallell process</h3>\\n<p>So we found a problem. Our worker is async. But it does not do work in parallell. This will definitely be a problem. To solve this we create a server which only has one job. Listen to messages, and for each message start a worker process that handles the heavy calculations (:timer.sleep in our case).</p>\\n<p>Show me some code!</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>defmodule ElixirTest.BasicWorker do\\n  def execute sender_pid do\\n    :timer.sleep(10000)\\n    send(sender_pid, {:ok, :pong})\\n  end\\nend\\n\\ndefmodule ElixirTest.BasicServer do\\n  def loop do\\n    receive do\\n      {sender_pid, _} ->\\n        worker_pid = spawn(ElixirTest.BasicWorker, :execute, [sender_pid])\\n        loop\\n    end\\n  end\\nend</code></pre>\\n      </div>\\n<p>For each message the server spawns a worker that does all the calculations and after sends a message to our iex pid.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>iex(7)> send(server_pid, {self, :ping})\\n{#PID<0.57.0>, :ping}\\niex(8)> send(server_pid, {self, :ping})\\n{#PID<0.57.0>, :ping}\\niex(9)> send(server_pid, {self, :ping})\\n{#PID<0.57.0>, :ping}\\niex(10)> send(server_pid, {self, :ping})\\n{#PID<0.57.0>, :ping}\\niex(11)> Process.info(server_pid)\\n[current_function: {ElixirTest.BasicServer, :loop, 0},\\n initial_call: {ElixirTest.BasicServer, :loop, 0}, status: :waiting,\\n message_queue_len: 0, messages: [], links: [], dictionary: [],\\n trap_exit: false, error_handler: :error_handler, priority: :normal,\\n group_leader: #PID<0.26.0>, total_heap_size: 233, heap_size: 233,\\n stack_size: 1, reductions: 1149,\\n garbage_collection: [min_bin_vheap_size: 46422, min_heap_size: 233,\\n  fullsweep_after: 65535, minor_gcs: 0], suspending: []]\\niex(12)> flush\\n:ok</code></pre>\\n      </div>\\n<p>No messages in the queue. All have been processed. Or started at least. We still haven’t received any messages. Wait around 10 seconds and the messages should start to come in.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"language-language-elixir\\\"><code>ex(15)> flush\\n{:ok, :pong}\\n{:ok, :pong}\\n:ok</code></pre>\\n      </div>\\n<p>Cool. So we built a async worker, which didn’t do any work in parallel. Then we modified it with a dispatcher and it got some parallel super powers.</p>\",\"frontmatter\":{\"title\":\"Playing around with Elixir Process\",\"date\":\"October 25, 2015\"}}},\"pathContext\":{\"slug\":\"/2015-10-25-playing-around-with-elixir-processes/\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/2015-2015-10-25-playing-around-with-elixir-processes.json\n// module id = 528\n// module chunks = 138779859493271"],"sourceRoot":""}