webpackJsonp([82145113734165],{512:function(e,n){e.exports={data:{site:{siteMetadata:{title:"Tinkering with Code.",author:"Simon Ström"}},markdownRemark:{id:"/Users/simon/Code/sajmoon.github.io/src/pages/1970-01-01-elixir-play-a-game-with-phoenix-channels.md absPath of file >>> MarkdownRemark",html:'<p>Let us play a game with channels in <a href="http://www.phoenixframework.org/">Phoenix</a>! A simple multiplayer game where the users is handed cards and are to take a some tricks. Using channels we can make a real time app like this in a breeze (I hope).</p>\n<h3>Rules</h3>\n<p>We are going to make a game called <a href="https://en.wikipedia.org/wiki/Oh_Hell">Oh hell</a>. Each player is handed a hand.\nThe player then have to guess how many tricks he will take. The player has to follow color, and the user with the “highest” card wins. There is Trump, a suite that is higher then the other. The user how guesses that he will take the most tricks decides which color will be the trump that round.</p>\n<h3>User interactions.</h3>\n<p>User joins the game lobby.\nWhen 4 joined the game starts.\nEach player is handed 10 cards.\nAll players guess how many tricks they will win that round.\nOne player decides trump, he also starts the round by selecting one card from his hand.\nThe other players take turn to place a card.\nThe one how wins this round gets a trick and starts the next round.\nWhen all players have played all cards, we see how many tricks each player has and if it matche the number the said the would get. Score is given accordingly.</p>\n<p>This game is called Plump in Swedish, and <a href="https://en.wikipedia.org/wiki/Oh_Hell">Oh hell</a> in english.</p>\n<h2>Development</h2>\n<p>We are going to start with the user interaction, since thats the channel part.</p>\n<p>Create a new phoenix project <code>mix phoenix.new plump</code>.\nBuild and compile everything you like then create a channel.</p>\n<div class="gatsby-highlight">\n      <pre class="language-language-bash"><code>~/C/plump ❯❯❯ mix phoenix.gen.channel Game games\n* creating web/channels/game_channel.ex\n* creating test/channels/game_channel_test.exs\n\nAdd the channel to your `web/channels/user_socket.ex` handler, for example:\n\n    channel "games:lobby", Plump.GameChannel</code></pre>\n      </div>\n<p>After you add your channel handler as described about we got a basic channel setup.</p>\n<p>Open test test file. We get a setup block and three tests from the generator.</p>\n<p>Let’s add our own test.</p>\n<h3>Let all users know a new user has joined.</h3>\n<p>Every time a user joins push a message letting everybody know there is a new friend in the lobby. Create a test to ensure we broadcast it to everyone.</p>\n<div class="gatsby-highlight">\n      <pre class="language-language-elixir"><code>  test "user joins channel a welcome message is sent", %{socket: socket} do\n    assert_broadcast "user:join", %{id: 1}\n  end</code></pre>\n      </div>\n<p>Run the tests and it breaks.</p>\n<div class="gatsby-highlight">\n      <pre class="language-language-elixir"><code>1) test user joins channel a welcome message is sent (Plump.GameChannelTest)\n     test/channels/game_channel_test.exs:12\n     No message matching %Phoenix.Socket.Broadcast{event: "user:join", payload: %{id: 1}} after 100ms.\n     The process mailbox is empty.\n     stacktrace:\n       test/channels/game_channel_test.exs:13</code></pre>\n      </div>\n<p>Our channel defines a join method that was generated by phoenix. So if we want to broadcast a message on join here might be the place to do that. This is how the code generated looks.</p>\n<div class="gatsby-highlight">\n      <pre class="language-language-elixir"><code>  def join("games:lobby", payload, socket) do\n    if authorized?(payload) do\n      {:ok, socket}\n    else\n      {:error, %{reason: "unauthorized"}}\n    end\n  end</code></pre>\n      </div>\n<p>First lets remove all the authorization that is going on. If you check the method <code>authorized?</code> it always returns true. It’s something that tells us where to put our implementation later when we need authentication. </p>\n<p>To broadcast on join we test a naïve solution. Call <code>broadcast socket "user:join", %{id: 1}</code> doesn’t work. Elixir provides us with a nice error message.</p>\n<div class="gatsby-highlight">\n      <pre class="language-language-elixir"><code>def join("games:lobby", payload, socket) do\n  broadcast socket, "shout", payload\n  {:ok, socket}\nend</code></pre>\n      </div>\n<p>Running the tests gives us this:</p>\n<div class="gatsby-highlight">\n      <pre class="language-language-elixir"><code>5) test shout broadcasts to games:lobby (Plump.GameChannelTest)\n     test/channels/game_channel_test.exs:27\n     ** (EXIT from #PID<0.249.0>) an exception was raised:\n         ** (RuntimeError) `push` and `broadcast` can only be called after the socket has finished joining.\n     To push a message on join, send to self and handle in handle_info/2, ie:\n\n         def join(topic, auth_msg, socket) do\n           ...\n           send(self, :after_join)\n           {:ok, socket}\n         end\n\n         def handle_info(:after_join, socket) do\n           push socket, "feed", %{list: feed_items(socket)}\n           {:noreply, socket}\n         end\n\n             (phoenix) lib/phoenix/channel.ex:346: Phoenix.Channel.assert_joined!/1\n             (phoenix) lib/phoenix/channel.ex:288: Phoenix.Channel.broadcast/3\n             (plump) web/channels/game_channel.ex:5: Plump.GameChannel.join/3\n             (phoenix) lib/phoenix/channel/server.ex:154: Phoenix.Channel.Server.init/1\n             (stdlib) gen_server.erl:328: :gen_server.init_it/6\n             (stdlib) proc_lib.erl:240: :proc_lib.init_p_do_apply/3</code></pre>\n      </div>\n<p>It tells us exactly why it didn’t work. We need to finish the join method and handle the broadcast later. Lets implement the exact solution provided to us.</p>\n<div class="gatsby-highlight">\n      <pre class="language-language-elixir"><code>  def join("games:lobby", payload, socket) do\n    send(self, :after_join)\n    {:ok, socket}\n  end\n\n  def handle_info(:after_join, socket) do\n    broadcast socket, "user:join", %{id: 1}\n    {:noreply, socket}\n  end</code></pre>\n      </div>\n<p>Tests are green!</p>\n<p>What happens when a second user joins? Refactor the tests, create a helper method to join users to the channel and test for the expected behavior.</p>\n<div class="gatsby-highlight">\n      <pre class="language-language-elixir"><code>defp join_channel channel_name, id do\n  {:ok, _, socket} =\n    socket("user_id", %{})\n    |> subscribe_and_join(GameChannel, channel_name)\n\n  {:ok, socket}\nend\n\nsetup do\n  {:ok, socket} = join_channel "games:lobby", 1\n\n  {:ok, socket: socket}\nend\n\ntest "user joins channel a welcome message is sent", %{socket: socket} do\n  assert_broadcast "user:join", %{id: 1}\nend\n\ntest "two users in a channel", %{socket: socket} do\n  assert_broadcast "user:join", %{id: 1}\n  user_2 = join_channel "games:lobby", 2\n  assert_broadcast "user:join", %{id: 2}\nend</code></pre>\n      </div>\n<p>Run the tests and they fail, since we hard coded what id should be sent with the broadcast.</p>\n<p>We modify how we connect to the server. We pass along a struct with the id of the user.</p>\n<div class="gatsby-highlight">\n      <pre class="language-language-elixir"><code>defp join_channel channel_name, id do\n  {:ok, _, socket} =\n    socket("user_id", %{})\n    |> subscribe_and_join(GameChannel, channel_name, %{id: id})\n\n  {:ok, socket}\nend</code></pre>\n      </div>\n<p>And in our implementation we claim the payload of the message and send it to all connected users with the <code>broadcast</code> method.</p>\n<div class="gatsby-highlight">\n      <pre class="language-language-elixir"><code>def join("games:lobby", payload, socket) do\n  send(self, {:after_join, payload})\n  {:ok, socket}\nend\n\ndef handle_info({:after_join, payload}, socket) do\n  broadcast socket, "user:join", payload\n  {:noreply, socket}\nend</code></pre>\n      </div>\n<p>And we are all green!</p>\n<h3>Keep a list of all active users.</h3>\n<p>We could use a database for this, but it seems a bit overkill. <code>Ecto</code> gives us a presistant layer to store things in. But we don’t need persistance now. Let us instead keep some state in an <code>Agent</code>. It will not be persisted but we could learn something about Agent. That sounds fun, everybody goes “Wee”!</p>\n<p>We start by writing some tests. We want the state to be initialized with a count of 0, and increased when we add users. The test file is located in <code>test/lib/game_store_test.exs</code>.</p>\n<div class="gatsby-highlight">\n      <pre class="language-language-elixir"><code>defmodule Plump.GameStoreTest do\n  use ExUnit.Case, async: false\n\n  setup do\n    {:ok, bucket} = Plump.GameStore.start_link\n    {:ok, bucket: bucket}\n  end\n\n  test "Initialized with count 0" do\n    assert Plump.GameStore.count == 0\n  end\n\n  test "add a player increases count of players" do\n    Plump.GameStore.add(%{id: 1})\n    assert Plump.GameStore.count == 1\n  end\nend</code></pre>\n      </div>\n<p>To implement this behavior we create the file <code>GameStore</code>as <code>lib/plump/game_store_test.exs</code>.</p>\n<div class="gatsby-highlight">\n      <pre class="language-language-elixir"><code>defmodule Plump.GameStore do\n  def start_link do\n    Agent.start_link(fn -> %{count: 0} end, name: __MODULE__)\n    {:ok, self}\n  end\n\n  def count do\n    Agent.get(__MODULE__, fn %{count: count} ->\n      count\n    end)\n  end\n\n  def add user do\n    Agent.update(__MODULE__, fn %{count: count} ->\n      %{count: count + 1}\n    end)\n  end\nend</code></pre>\n      </div>\n<p>This is a simple agent that only stores a count, we will need to modify this later to keep track of the users too.</p>\n<p>We have made some decisions about the agent that we might want to reconsider. The agent is named, thus we can only have one. This is fine, but you should be aware that the agent is unique because of it.</p>\n<p>Also, the test setup block returns the bucket pid, aka the pid to the agent. That is not necessary since we have named it and could be removed. However, the pattern matching for <code>{:ok, bucket}</code>also serves to ensure that starting the Agent returned <code>:ok</code>. So it’s like an assertion.</p>\n<h3>Display the stats when new users join.</h3>\n<p>So, all the work we put in to create the Agent should be used. When a new users joins we want to know how many users have joined so far.</p>\n<p>We modify the tests.</p>\n<div class="gatsby-highlight">\n      <pre class="language-language-elixir"><code>test "user joins channel a message is sent, and nr of players in channel" do\n  assert_broadcast "user:join", %{id: 1}\n  assert_broadcast "user:stats", %{count: 1}\nend\n\ntest "two users in a channel" do\n  assert_broadcast "user:join", %{id: 1}\n  assert_broadcast "user:stats", %{count: 1}\n  join_channel "games:lobby", 2\n  assert_broadcast "user:join", %{id: 2}\n  assert_broadcast "user:stats", %{count: 2}\nend</code></pre>\n      </div>\n<p>That is the behavior we want. Now over to the implementation.</p>\n<div class="gatsby-highlight">\n      <pre class="language-language-elixir"><code>def join("games:lobby", payload, socket) do\n  Plump.GameStore.add payload\n  send(self, {:after_join, payload})\n  {:ok, socket}\nend\n\ndef handle_info({:after_join, payload}, socket) do\n  broadcast socket, "user:join", payload\n  count = Plump.GameStore.count\n  broadcast socket, "user:stats", %{count: count}\n  {:noreply, socket}\nend</code></pre>\n      </div>\n<p>This is pretty straight forward; when a user joins we add it to the agent, and broadcast the updated statistics to all users.</p>\n<p>Already here we see a problem in our design. GameStore.count returns a primitive value, but that is clear that we should have named that function statistics and it should have returned a struct <code>%{count: count}</code>. That would have made it easy to extend with information about running games, when the time comes.</p>\n<p>This will still not make our tests green. For that we need to start the agent before the tests.</p>\n<div class="gatsby-highlight">\n      <pre class="language-language-elixir"><code>setup do\n  {:ok, bucket} = Plump.GameStore.start_link()\n  {:ok, socket} = join_channel "games:lobby", 1\n\n  {:ok, socket: socket}\nend</code></pre>\n      </div>\n<p>This step is needed because we have not added the Agent to our application tree yet. This works for now.</p>\n<h3>Refactoring.</h3>\n<p>As we can see above, we have some methods that could use a new name and a new return type.</p>\n<p>We start with how we want to use it:</p>\n<div class="gatsby-highlight">\n      <pre class="language-language-elixir"><code>def handle_info({:after_join, payload}, socket) do\n  broadcast socket, "user:join", payload\n  statistics = Plump.GameStore.statistics\n  broadcast socket, "user:stats", statistics\n  {:noreply, socket}\nend</code></pre>\n      </div>\n<p>Fix the GameStore accordingly.</p>\n<div class="gatsby-highlight">\n      <pre class="language-language-elixir"><code>def statistics do\n  Agent.get(__MODULE__, fn %{count: count} ->\n    %{count: count}\n  end)\nend</code></pre>\n      </div>\n<p>And the tests.</p>\n<div class="gatsby-highlight">\n      <pre class="language-language-elixir"><code>test "Initialized with count 0" do\n  %{count: count} = Plump.GameStore.statistics\n  assert count == 0\nend\n\ntest "add a player increases count of players" do\n  Plump.GameStore.add(%{id: 1})\n  %{count: count} = Plump.GameStore.statistics\n  assert count == 1\nend</code></pre>\n      </div>\n<p>Also refactor how the <code>:after_join</code> is handles.</p>\n<div class="gatsby-highlight">\n      <pre class="language-language-elixir"><code>def handle_info({:after_join, payload}, socket) do\n  statistics = Plump.GameStore.statistics\n\n  %{socket: socket, statistics: statistics}\n  |> broadcast_user_join(payload)\n  |> broadcast_statistics()\n\n  {:noreply, socket}\nend\n\ndefp broadcast_user_join %{socket: socket, statistics: statistics} = params, payload do\n  broadcast socket, "user:join", payload\n  params\nend\n\ndefp broadcast_statistics %{socket: socket, statistics: statistics} = params do\n  broadcast socket, "user:stats", statistics\n  params\nend</code></pre>\n      </div>\n<p>Perfect. Each of the private functions return the <code>socket</code> so we can continue the pipe.</p>\n<h3>Start the game.</h3>\n<p>When we have 4 players we should start the game.\nEvery game should have an own channel.\nThe players should get cards.\nLet’s start with that.</p>\n<div class="gatsby-highlight">\n      <pre class="language-language-elixir"><code>test "If 4 players, the game should start", %{socket: socket} do\n  join_channel "games:lobby", 2\n  join_channel "games:lobby", 3\n  join_channel "games:lobby", 4\n\n  assert_broadcast "user:stats", %{count: 4}\n\n  assert_broadcast "game:start", %{users: [1, 2, 3, 4]}\nend</code></pre>\n      </div>\n<p>We join the game, and add 3 more players. This is a bit ugly and should be change. Now we don’t want the first user to be added automatically.</p>\n<p>Remove the join_channel statement from the setup block, and add the user 1 to the game where needed.</p>\n<p>Run the tests and they fail. I decided to send a list of all users who are to be in the current game as payload.</p>\n<p>Implementation time!</p>\n<div class="gatsby-highlight">\n      <pre class="language-language-elixir"><code>def handle_info({:after_join, payload}, socket) do\n  statistics = Plump.GameStore.statistics\n\n  %{socket: socket, statistics: statistics}\n  |> broadcast_user_join(payload)\n  |> broadcast_statistics()\n  |> start_game()\n\n  {:noreply, socket}\nend\n\ndefp start_game %{socket: socket, statistics: %{count: 4}} = params do\n  broadcast socket, "game:start", %{users: [1,2,3,4]}\n  {:ok, params}\nend\ndefp start_game params do\n  {:error, params}\nend</code></pre>\n      </div>\n<p>We have hard coded the user ids. To fix this we need to fix our store.</p>\n<p>We should store all users, and all games created. Not just a count of each.</p>\n<p>We update the tests and the store.</p>\n<div class="gatsby-highlight">\n      <pre class="language-language-elixir"><code>test "list players" do\n  Plump.GameStore.add(%{id: 1})\n\n  assert 1 == Plump.GameStore.players\n  |> HashDict.to_list()\n  |> Enum.count()\nend\n\ntest "create a new game" do\n  %{game_count: count} = Plump.GameStore.statistics\n  assert count == 0\n\n  Plump.GameStore.new_game(%{game_id: 1})\n  %{game_count: count} = Plump.GameStore.statistics\n  assert count == 1\n\n  assert 1 == Plump.GameStore.games\n  |> HashDict.to_list()\n  |> Enum.count()\nend</code></pre>\n      </div>\n<p>These tests assume we have a <code>games</code> and <code>players</code> method returning a HashDict of players.</p>\n<p>Let’s change the store to match. We also update the games counter to a new name, <code>games_count</code>.</p>\n<p>We initialize the state we need.</p>\n<div class="gatsby-highlight">\n      <pre class="language-language-elixir"><code>def start_link do\n  Agent.start_link(fn -> %{count: 0, game_count: 0, users: HashDict.new, games: HashDict.new} end, name: __MODULE__)\n  {:ok, self}\nend</code></pre>\n      </div>\n<p>And create the methods to return the players and games.</p>\n<div class="gatsby-highlight">\n      <pre class="language-language-elixir"><code>def players do\n  Agent.get(__MODULE__, fn %{users: users} = state ->\n    users\n  end)\nend\n\ndef games do\n  Agent.get(__MODULE__, fn %{games: games} = state ->\n    games\n  end)\nend</code></pre>\n      </div>\n<p>To add them to the respective list we need to modify the add user and new_games methods.</p>\n<div class="gatsby-highlight">\n      <pre class="language-language-elixir"><code>def new_game game do\n  Agent.update(__MODULE__, fn %{game_count: game_count, games: games} = state ->\n    games = HashDict.put(games, game.game_id, game)\n    %{state | game_count: game_count + 1, games: games}\n  end)\nend</code></pre>\n      </div>\n<p>Alright, we create the failing test to test the user id list and a game id. We are using 1 for now.</p>\n<div class="gatsby-highlight">\n      <pre class="language-language-elixir"><code>test "broadcast of new games contains user ids" do\n  join_channel "games:lobby", 10\n  join_channel "games:lobby", 20\n  join_channel "games:lobby", 30\n  join_channel "games:lobby", 40\n\n  assert_broadcast "user:stats", %{count: 4}\n\n  assert_broadcast "game:start", %{users: [10, 20, 30, 40], game_id: 1}\nend</code></pre>\n      </div>\n<p>We return a list of keys.</p>\n<div class="gatsby-highlight">\n      <pre class="language-language-elixir"><code>defp start_game %{socket: socket, statistics: %{count: 4}} = params do\n  players = Plump.GameStore.players()\n\n  player_keys = players\n  |> HashDict.keys()\n  |> Enum.sort()\n\n  game_id = 1\n  Plump.GameStore.new_game %{game_id: game_id, players: players}\n\n  broadcast socket, "game:start", %{users: player_keys, game_id: game_id}\n  {:ok, params}\nend</code></pre>\n      </div>\n<p>We have some major problems with our implementation so far. For example if more people then 4 join, what happens?</p>\n<h3>Game room</h3>\n<p>That way the user can see if s/he was selected to join the game. That is it for the lobby part of the game. Next we need to move the selected players to a game room for that specific game and hand them cards.</p>\n<div class="gatsby-highlight">\n      <pre class="language-language-bash"><code>$ mix phoenix.gen.channel Room rooms                                                                                                                             master\n* creating web/channels/room_channel.ex\n* creating test/channels/room_channel_test.exs\n\nAdd the channel to your `web/channels/user_socket.ex` handler, for example:\n\n    channel "rooms:lobby", Plump.RoomChannel</code></pre>\n      </div>\n<p>We create a room channel to handle the gameplay. Make sure to add it with a wildcard.</p>\n<div class="gatsby-highlight">\n      <pre class="language-language-elixir"><code>channel "rooms:*", Plump.RoomChannel</code></pre>\n      </div>\n<p>Also clear out the test and channel code generated for us by Phoenix generators.</p>',frontmatter:{title:"Elixir: Play a game with Phoenix channels.",date:"January 01, 1970"}}},pathContext:{slug:"/1970-01-01-elixir-play-a-game-with-phoenix-channels/"}}}});
//# sourceMappingURL=path---1970-1970-01-01-elixir-play-a-game-with-phoenix-channels-d90438d6e6983a5c3ce5.js.map