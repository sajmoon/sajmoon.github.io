webpackJsonp([82275407414035],{527:function(e,o){e.exports={data:{site:{siteMetadata:{title:"Tinkering with Code.",author:"Simon Ström"}},markdownRemark:{id:"/Users/simon/Code/sajmoon.github.io/src/pages/2015-10-25-elixir-a-simple-server-with-plug.md absPath of file >>> MarkdownRemark",html:'<p>If you want to build a web service with Elixir, you are probably using some framework such as <a href="http://www.phoenixframework.org/">Phoenix</a>. And that is all fine. You probably should. But Phoenix does a lot of things in the background that are semi hidden from you as a developer. So it is no way to learn the inner workings of Elixir.</p>\n<p>So by building a small, simple service, using <a href="https://github.com/elixir-lang/plug">Plug</a> you could learn something.</p>\n<p>Lets start.</p>\n<h2>Getting started</h2>\n<p>I have some data I would like to present as an api or through a web page. So to my existing project I add the dependencies we need. <code>Plug</code>and <code>Cowboy</code>. </p>\n<div class="gatsby-highlight">\n      <pre class="language-language-elixir"><code>defp deps do\n  # Excluding other dependencies.\n  {:cowboy, "~> 1.0.3"},\n  {:plug, "~> 1.0"},\nend</code></pre>\n      </div>\n<p>Both Cowboy and Plug is an Erlang/Elixir application in it self. That is the Erlang/Elixir way to divide a project into modules or components. That basically means we communicate with them by sending messages to them.</p>\n<p>It also means we have to make sure they are started.</p>\n<p>We do that in the <code>def application do</code> block. Add both cowboy and plug. We also have to have a <code>mod</code> element. </p>\n<div class="gatsby-highlight">\n      <pre class="language-language-elixir"><code>[applications:\n   [:logger, :httpotion, :cowboy, :plug],\n   mod: {HexVersion.Api, []}\n]</code></pre>\n      </div>\n<p>This tells mix how to start your application, what dependencies needs to be started etc. We are going to define a supervisor to controll our application so we need to ensure that is starts and stops as the applications starts. We do this by defining a module callback. This is <code>mod:</code>.\nmod takes one tuple parameter on the form <code>{m, a}</code>. <strong>m</strong> stands for Module, and <strong>a</strong> for Arguments. It just tells mix to start our supervisor in HexVersion.Api.</p>\n<p>So lets create that supervisor.</p>\n<h2>Supervisor</h2>\n<p>A supervisor keeps track of all “workers” under it, and can restart one if it crashes. This is a standard component of the <em>Erlang/OTP pattern</em>. OTP is a way to design applications to be fault tolerant. It is a big and important aspect of both erlang and elixir.</p>\n<p>Anyways, back to the supervisor.</p>\n<div class="gatsby-highlight">\n      <pre class="language-language-elixir"><code>defmodule HexVersion.Api do\n  use Application\n\n  def start(_type, _args) do\n    import Supervisor.Spec, warn: false\n\n    children = [\n      worker(HexVersion.Web, [])\n    ]\n\n    opts = [strategy: :one_for_one, name: HexVersion.Supervisor]\n    Supervisor.start_link(children, opts)\n  end\nend</code></pre>\n      </div>\n<p>Alright. We define a method <code>start</code> that is the method which will be called on boot, since we added it to the <code>def application do</code>.</p>\n<p>At the last line of that block we run <code>Supervisor.start_link(children, opts)</code>. We create a supervisor which will keep track of all children. The children is a list of OTP compliant modules. They need to have a <code>start_link</code> function.\n<code>opts</code> tells the supervisor when and how to restart crashed process. <code>:one_for_one</code> starts one process if one crashes. We could restart every process if for example they depend on each other.</p>\n<p>Cool, we have a supervisor that starts our web worker. We do not have a web worker though.</p>\n<p>So create a simple worker that takes a connection and responds with a 200, “ok”. Simple enough. Its a good start though.</p>\n<h2>Web Worker</h2>\n<p>This is where the plug magic comes in. </p>\n<div class="gatsby-highlight">\n      <pre class="language-language-elixir"><code>defmodule HexVersion.Web do\n  use Plug.Router\n  require Logger\n\n  plug Plug.Logger\n  plug :match\n  plug :dispatch\n\n  def init(options) do\n    options\n  end\n\n  def start_link do\n    {:ok, _} = Plug.Adapters.Cowboy.http HexVersion.Web, []\n  end\n\n  get "/" do\n    conn\n    |> send_resp(200, "ok")\n    |> halt\n  end\nend</code></pre>\n      </div>\n<p>You can read more about <a href="https://github.com/elixir-lang/plug">Plug</a> from the github page.</p>\n<p>We define a route, ”/” and define what should happen when that route matches. In this case we just send a response with status <code>200</code> and the text “ok”.</p>\n<p>But the <code>start_link</code> and <code>init</code> then? This is a function that tells the supervisor how to start a process of this type.</p>\n<p>Right. Shall we test it?</p>\n<p>Start your application.\n<code>$ iex -S mix</code></p>\n<p>Make a request to the service.\n<code>$ curl localhost:4000</code></p>\n<p>That request returns “ok”. Awesome. If you look in your iex session you will see the logger at work.</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>14:06:47.973 [info]  GET /\n14:06:47.974 [info]  Sent 200 in 1ms</code></pre>\n      </div>\n<p>It works great doing requests using the terminal. Lets try a browser.</p>\n<p>It works! We get the correct text. Check the log from your application.</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>14:28:32.611 [info]  GET /favicon.ico\n\n14:28:32.642 [error] #PID<0.285.0> running HexVersion.Web terminated\nServer: localhost:4000 (http)\nRequest: GET /favicon.ico\n** (exit) an exception was raised:\n    ** (FunctionClauseError) no function clause matching in HexVersion.Web.do_match/4\n        (hex_version) lib/hex_version/web.ex:19: HexVersion.Web.do_match(%Plug.Conn{adapter: {Plug.Adapters.Cowboy.Conn, :...}, assigns: %{}, before_send: \n\n... etc etc.. Removed for brevity\n\n        (hex_version) lib/hex_version/web.ex:1: HexVersion.Web.plug_builder_call/2\n        (plug) lib/plug/adapters/cowboy/handler.ex:15: Plug.Adapters.Cowboy.Handler.upgrade/4\n        (cowboy) src/cowboy_protocol.erl:442: :cowboy_protocol.execute/4</code></pre>\n      </div>\n<p>Okey, thats a stack trace. So what happened? Well the browser did some extra requests. For example one to get the favicon. We did not have one, since the only route we have specified is <code>"/"</code> so when the browser executes the request to <code>"/favicon.ico"</code>, Plug cannot match it.</p>\n<p>The line to look for is at the top: <code>(FunctionClauseError) no function clause matching in HexVersion.Web.do_match/4</code>.</p>\n<p>We get the same results if we from the terminal would curl a route that we have not specified, say for example <code>/nope</code>.</p>\n<div class="gatsby-highlight">\n      <pre class="language-none"><code>14:32:50.334 [info]  GET /nope\n\n14:32:50.398 [error] #PID<0.293.0> running HexVersion.Web terminated\nServer: localhost:4000 (http)\nRequest: GET /nope\n** (exit) an exception was raised:\n    ** (FunctionClauseError) no function clause matching in HexVersion.Web.do_match/4</code></pre>\n      </div>\n<p>To fix this we need to provide a route or a matcher that takes any request that we haven’t specified a matcher for. A wildcard.</p>\n<div class="gatsby-highlight">\n      <pre class="language-language-elixir"><code>match _ do\n  conn\n  |> send_resp(404, "Nothing here")\n  |> halt\nend</code></pre>\n      </div>\n<p>Simple enough. No more stack traces.</p>\n<p>However, still no favicon. Either we don’t need a favicon (an api for example), or we just hid the problem.</p>\n<p>There are plugs to help you serve static assets such as favicons, or .html files. Check out the plug site for more on that.</p>\n<h2>Conclusion</h2>\n<p>Well, we got our service up and running. It is a very simple example, but it’s free from Phoenix. Phoneix is easy to use and it is very good, but you might not always need it, or you might wounder what actually goes on inside it. This is whats happending. Phoneix uses Plug, and matches, and routes. It comes with a supervisor and all just wired up for you. Which is nice. But be sure you understand what actually is going on. </p>',frontmatter:{title:"Elixir: A simple server with Plug",date:"October 25, 2015"}}},pathContext:{slug:"/2015-10-25-elixir-a-simple-server-with-plug/"}}}});
//# sourceMappingURL=path---2015-2015-10-25-elixir-a-simple-server-with-plug-8c4aad950661225db441.js.map